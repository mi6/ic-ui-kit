/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { IcActivationTypes, IcAdditionalFieldTypes, IcAlignment, IcAutocompleteTypes, IcAutocorrectStates, IcBlurEventDetail, IcEmphasisType, IcInformationStatusOrEmpty, IcMenuOption, IcOrientation, IcSearchMatchPositions, IcSizes, IcSizesNoLarge, IcStatusVariants, IcTheme, IcThemeForeground, IcThemeForegroundNoDefault, IcTypographyVariants, IcValueEventDetail } from "./utils/types";
import { IcBadgePositions, IcBadgeTypes, IcBadgeVariants, IcColor } from "./components/ic-badge/ic-badge.types";
import { IcButtonTooltipPlacement, IcButtonTypes, IcButtonVariants } from "./components/ic-button/ic-button.types";
import { IcChangeEventDetail } from "./components/ic-checkbox-group/ic-checkbox-group.types";
import { IcChipAppearance } from "./components/ic-chip/ic-chip.types";
import { IcProtectiveMarkings } from "./components/ic-classification-banner/ic-classification-banner.types";
import { IcEmptyStateAlignment } from "./components/ic-empty-state/ic-empty-state.types";
import { IcFooterBreakpoints } from "./components/ic-footer/ic-footer.types";
import { IcHeroContentAlignments } from "./components/ic-hero/ic-hero.types";
import { IcAriaLiveModeVariants } from "./components/ic-input-validation/ic-input-validation.types";
import { IcLoadingSizes, IcLoadingTypes } from "./components/ic-loading-indicator/ic-loading-indicator.types";
import { IcSearchBarBlurEventDetail, IcSearchBarSearchModes } from "./components/ic-search-bar/ic-search-bar.types";
import { IcMenuChangeEventDetail, IcMenuOptionIdEventDetail, IcOptionSelectEventDetail } from "./components/ic-menu/ic-menu.types";
import { IcMenuItemVariants } from "./components/ic-menu-item/ic-menu-item.types";
import { IcChangeEventDetail as IcChangeEventDetail1, IcPaginationTypes } from "./components/ic-pagination/ic-pagination.types";
import { IcPaginationItemType } from "./components/ic-pagination-item/ic-pagination-item.types";
import { IcChangeEventDetail as IcChangeEventDetail2 } from "./components/ic-radio-group/ic-radio-group.types";
import { IcExpandedDetail } from "./components/ic-side-navigation/ic-side-navigation.types";
import { IcSkeletonVariants } from "./components/ic-skeleton/ic-skeleton.types";
import { IcStatusTagAppearance, IcStatusTagStatuses } from "./components/ic-status-tag/ic-status-tag.types";
import { IcStepStatuses, IcStepTypes, IcStepVariants } from "./components/ic-step/ic-step.types";
import { IcStepperAlignment } from "./components/ic-stepper/ic-stepper.types";
import { IcSwitchChangeEventDetail } from "./components/ic-switch/ic-switch.types";
import { IcTabClickEventDetail, IcTabSelectEventDetail } from "./components/ic-tab/ic-tab.types";
import { IcAriaAutocompleteTypes, IcTextFieldInputModes, IcTextFieldTypes } from "./components/ic-text-field/ic-text-field.types";
import { IcTooltipPlacements } from "./components/ic-tooltip/ic-tooltip.types";
export { IcActivationTypes, IcAdditionalFieldTypes, IcAlignment, IcAutocompleteTypes, IcAutocorrectStates, IcBlurEventDetail, IcEmphasisType, IcInformationStatusOrEmpty, IcMenuOption, IcOrientation, IcSearchMatchPositions, IcSizes, IcSizesNoLarge, IcStatusVariants, IcTheme, IcThemeForeground, IcThemeForegroundNoDefault, IcTypographyVariants, IcValueEventDetail } from "./utils/types";
export { IcBadgePositions, IcBadgeTypes, IcBadgeVariants, IcColor } from "./components/ic-badge/ic-badge.types";
export { IcButtonTooltipPlacement, IcButtonTypes, IcButtonVariants } from "./components/ic-button/ic-button.types";
export { IcChangeEventDetail } from "./components/ic-checkbox-group/ic-checkbox-group.types";
export { IcChipAppearance } from "./components/ic-chip/ic-chip.types";
export { IcProtectiveMarkings } from "./components/ic-classification-banner/ic-classification-banner.types";
export { IcEmptyStateAlignment } from "./components/ic-empty-state/ic-empty-state.types";
export { IcFooterBreakpoints } from "./components/ic-footer/ic-footer.types";
export { IcHeroContentAlignments } from "./components/ic-hero/ic-hero.types";
export { IcAriaLiveModeVariants } from "./components/ic-input-validation/ic-input-validation.types";
export { IcLoadingSizes, IcLoadingTypes } from "./components/ic-loading-indicator/ic-loading-indicator.types";
export { IcSearchBarBlurEventDetail, IcSearchBarSearchModes } from "./components/ic-search-bar/ic-search-bar.types";
export { IcMenuChangeEventDetail, IcMenuOptionIdEventDetail, IcOptionSelectEventDetail } from "./components/ic-menu/ic-menu.types";
export { IcMenuItemVariants } from "./components/ic-menu-item/ic-menu-item.types";
export { IcChangeEventDetail as IcChangeEventDetail1, IcPaginationTypes } from "./components/ic-pagination/ic-pagination.types";
export { IcPaginationItemType } from "./components/ic-pagination-item/ic-pagination-item.types";
export { IcChangeEventDetail as IcChangeEventDetail2 } from "./components/ic-radio-group/ic-radio-group.types";
export { IcExpandedDetail } from "./components/ic-side-navigation/ic-side-navigation.types";
export { IcSkeletonVariants } from "./components/ic-skeleton/ic-skeleton.types";
export { IcStatusTagAppearance, IcStatusTagStatuses } from "./components/ic-status-tag/ic-status-tag.types";
export { IcStepStatuses, IcStepTypes, IcStepVariants } from "./components/ic-step/ic-step.types";
export { IcStepperAlignment } from "./components/ic-stepper/ic-stepper.types";
export { IcSwitchChangeEventDetail } from "./components/ic-switch/ic-switch.types";
export { IcTabClickEventDetail, IcTabSelectEventDetail } from "./components/ic-tab/ic-tab.types";
export { IcAriaAutocompleteTypes, IcTextFieldInputModes, IcTextFieldTypes } from "./components/ic-text-field/ic-text-field.types";
export { IcTooltipPlacements } from "./components/ic-tooltip/ic-tooltip.types";
export namespace Components {
    interface IcAccordion {
        "appearance"?: IcThemeForeground;
        /**
          * If `true`, the accordion will be disabled.
         */
        "disabled"?: boolean;
        /**
          * If `true`, the accordion appears expanded.
         */
        "expanded": boolean;
        /**
          * The section header outlining section content.
         */
        "heading"?: string;
        /**
          * The main body message of the accordion.
         */
        "message"?: string;
        /**
          * Sets focus on accordion heading.
         */
        "setFocus": () => Promise<void>;
        /**
          * The size of the accordion.
         */
        "size"?: IcSizes;
    }
    interface IcAccordionGroup {
        /**
          * The accessible button label to provide more context to the 'See all/Hide all' button for screen reader users.
         */
        "accessibleButtonLabel": string;
        /**
          * The appearance of the accordion group, e.g dark, or light.
         */
        "appearance": IcThemeForeground;
        /**
          * If `true`, the accordion will load in an expanded state.
         */
        "expanded": boolean;
        /**
          * The header for the accordion group.
         */
        "groupTitle": string;
        /**
          * If `true`, only one accordion will open at a time.
         */
        "singleExpansion": boolean;
        /**
          * The size of the accordion.
         */
        "size"?: IcSizes;
    }
    interface IcAlert {
        /**
          * If `true`, the alert will have the 'alert' ARIA role and will be announced to screen readers.
         */
        "announced"?: boolean;
        /**
          * If `true`, the alert will have a close icon at the end to dismiss it.
         */
        "dismissible"?: boolean;
        /**
          * The optional title to display at the start of the alert.
         */
        "heading"?: string;
        /**
          * The main body message of the alert.
         */
        "message"?: string;
        /**
          * If `true`, the title and message will appear above and below instead of inline.
         */
        "titleAbove"?: boolean;
        /**
          * The variant of the alert which will be rendered.
         */
        "variant"?: IcStatusVariants;
    }
    interface IcBackToTop {
        /**
          * The ID of the element to jump back to when the link is clicked.
         */
        "target": string;
    }
    interface IcBadge {
        /**
          * The accessible label of the badge component to provide context for screen reader users.
         */
        "accessibleLabel"?: string;
        /**
          * The custom badge colour. This will only style the badge component if variant="custom". Can be a hex value e.g. "#ff0000", RGB e.g. "rgb(255, 0, 0)", or RGBA e.g. "rgba(255, 0, 0, 1)".
         */
        "customColor"?: IcColor;
        /**
          * @deprecated This method should not be used anymore. Use visible prop to set badge visibility.
         */
        "hideBadge": () => Promise<void>;
        /**
          * The maximum number shown on the badge appended with a +. This will only be displayed if type="text" and textLabel is not empty.
         */
        "maxNumber"?: number;
        /**
          * The positioning of the badge in reference to the parent element.
         */
        "position"?: IcBadgePositions;
        /**
          * @deprecated This method should not be used anymore. Use visible prop to set badge visibility.
         */
        "showBadge": () => Promise<void>;
        /**
          * The size of the badge to be displayed.
         */
        "size"?: IcSizes;
        /**
          * The text displayed in the badge. This will only be displayed if type="text".
         */
        "textLabel"?: string;
        /**
          * The type of badge to be displayed.
         */
        "type"?: IcBadgeTypes;
        /**
          * The variant of the badge to be displayed.
         */
        "variant"?: IcBadgeVariants;
        /**
          * If `true`, the badge will be displayed.
         */
        "visible": boolean;
    }
    interface IcBreadcrumb {
        "appearance": IcThemeForeground;
        /**
          * If `true`, aria-current will be set on the breadcrumb.
         */
        "current"?: boolean;
        /**
          * The URL that the breadcrumb link points to.
         */
        "href"?: string;
        /**
          * The title of the breadcrumb.
         */
        "pageTitle": string;
        /**
          * Sets focus on the breadcrumb.
         */
        "setFocus": () => Promise<void>;
        "showBackIcon": boolean;
    }
    interface IcBreadcrumbGroup {
        /**
          * The appearance of the breadcrumb group.
         */
        "appearance": IcThemeForeground;
        /**
          * If `true`, display only a single breadcrumb for the parent page with a back icon.
         */
        "backBreadcrumbOnly": boolean;
        /**
          * If `true`, all breadcrumbs between the first and last breadcrumb will be collapsed.
         */
        "collapsed": boolean;
    }
    interface IcButton {
        /**
          * If `fileUpload` is set to `true`, this is the accepted list of file types.
         */
        "accept"?: string;
        /**
          * The appearance of the button, e.g. dark, light, or the default.
         */
        "appearance"?: IcThemeForeground;
        "ariaControlsId": string | boolean;
        "ariaOwnsId": string | boolean;
        /**
          * If `true`, the ic-tooltip which is shown for icon variant will be disabled. Title or aria-label must be set if this prop is not applied.
         */
        "disableTooltip"?: boolean;
        /**
          * If `true`, the button will be in disabled state.
         */
        "disabled"?: boolean;
        /**
          * If `true`, the user can save the linked URL instead of navigating to it.
         */
        "download"?: string | boolean;
        /**
          * If `true`, the button will show a dropdown icon.
         */
        "dropdown"?: boolean;
        /**
          * If `true`, the aria-expanded value will be set to true. This is only applied if the dropdown prop is also true.
         */
        "dropdownExpanded"?: boolean;
        /**
          * The name of the control for the file input, which is submitted with the form data.
         */
        "fileInputName": string;
        /**
          * If `true`, when the button is clicked the native file explorer will be launched.
         */
        "fileUpload"?: boolean;
        /**
          * The <form> element to associate the button with.
         */
        "form"?: string;
        /**
          * The URL that processes the information submitted by the button. It overrides the action attribute of the button's form owner. Does nothing if there is no form owner.
         */
        "formaction"?: string;
        /**
          * The way the submitted form data is encoded.
         */
        "formenctype"?: string;
        /**
          * The HTTP method used to submit the form.
         */
        "formmethod"?: string;
        /**
          * If `true`, the form will not be validated when submitted.
         */
        "formnovalidate"?: boolean;
        /**
          * The place to display the response from submitting the form. It overrides the target attribute of the button's form owner.
         */
        "formtarget"?: string;
        /**
          * If `true`, the button will fill the width of the container.
         */
        "fullWidth"?: boolean;
        /**
          * The URL that the link points to. This will render the button as an "a" tag.
         */
        "href"?: string;
        /**
          * The human language of the linked URL.
         */
        "hreflang"?: string;
        /**
          * If `true`, the button will be in loading state.
         */
        "loading"?: boolean;
        /**
          * If `fileUpload` is set to `true`, this boolean determines whether multiple files are accepted.
         */
        "multiple"?: boolean;
        /**
          * How much of the referrer to send when following the link.
         */
        "referrerpolicy"?: ReferrerPolicy;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string;
        /**
          * The list of the files that have been selected by a user.
         */
        "selectedFiles": FileList;
        /**
          * Sets focus on the native `button`.
         */
        "setFocus": () => Promise<void>;
        /**
          * The size of the button to be displayed.
         */
        "size"?: IcSizes;
        /**
          * The place to display the linked URL, as the name for a browsing context (a tab, window, or iframe).
         */
        "target"?: string;
        /**
          * The position of the tooltip in relation to the button.
         */
        "tooltipPlacement"?: IcButtonTooltipPlacement;
        /**
          * If `true`, the secondary variant of button will have a transparent background rather than white.
         */
        "transparentBackground"?: boolean;
        /**
          * The type of the button.
         */
        "type"?: IcButtonTypes;
        /**
          * The variant of the button to be displayed.
         */
        "variant"?: IcButtonVariants;
    }
    interface IcCard {
        /**
          * If `true`, the card will be a clickable variant, instead of static.
         */
        "clickable"?: boolean;
        /**
          * If `true`, the card will be disabled if it is clickable.
         */
        "disabled"?: boolean;
        /**
          * If `true`, the card will have an expandable area and expansion toggle button.
         */
        "expandable"?: boolean;
        /**
          * If `true`, the card will fill the width of the container.
         */
        "fullWidth"?: boolean;
        /**
          * The heading for the card. This is required, unless a slotted heading is used.
         */
        "heading"?: string;
        /**
          * The URL that the clickable card link points to. If set, the clickable card will render as an "a" tag, otherwise it will render as a button.
         */
        "href"?: string | undefined;
        /**
          * The human language of the linked URL.
         */
        "hreflang"?: string;
        /**
          * The main body message of the card.
         */
        "message"?: string;
        /**
          * How much of the referrer to send when following the link.
         */
        "referrerpolicy"?: ReferrerPolicy;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string;
        /**
          * Sets focus on the card.
         */
        "setFocus": () => Promise<void>;
        /**
          * The subheading for the card.
         */
        "subheading"?: string;
        /**
          * The place to display the linked URL, as the name for a browsing context (a tab, window, or iframe).
         */
        "target"?: string;
    }
    interface IcCheckbox {
        /**
          * The style of additionalField that will be displayed if used.
         */
        "additionalFieldDisplay": IcAdditionalFieldTypes;
        /**
          * If `true`, the checkbox will be set to the checked state.
         */
        "checked"?: boolean;
        /**
          * If `true`, the checkbox will be set to the disabled state.
         */
        "disabled"?: boolean;
        /**
          * The text to be displayed when dynamic.
         */
        "dynamicText": string;
        /**
          * The <form> element to associate the checkbox with.
         */
        "form"?: string;
        /**
          * The URL that processes the information submitted by the checkbox. It overrides the action attribute of the checkbox's form owner. Does nothing if there is no form owner.
         */
        "formaction"?: string;
        /**
          * The way the submitted form data is encoded.
         */
        "formenctype"?: string;
        /**
          * The HTTP method used to submit the form.
         */
        "formmethod"?: string;
        /**
          * If `true`, the form will not be validated when submitted.
         */
        "formnovalidate"?: boolean;
        /**
          * The place to display the response from submitting the form. It overrides the target attribute of the checkbox's form owner.
         */
        "formtarget"?: string;
        /**
          * The group label for the checkbox.
         */
        "groupLabel": string;
        /**
          * If `true`, the indeterminate state will be displayed when checked.
         */
        "indeterminate": boolean;
        /**
          * The label for the checkbox.
         */
        "label": string;
        /**
          * The name for the checkbox. If not set when used in a checkbox group, the name will be based on the group name.
         */
        "name": string;
        /**
          * Sets focus on the checkbox.
         */
        "setFocus": () => Promise<void>;
        /**
          * The size of the checkbox to be displayed. This does not affect the font size of the label. If a checkbox is contained in a checkbox group, this will override the size set on checkbox group.
         */
        "size"?: IcSizes;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * The value for the checkbox.
         */
        "value": string;
    }
    interface IcCheckboxGroup {
        /**
          * If `true`, the checkbox group will be set to the disabled state.
         */
        "disabled": boolean;
        /**
          * The helper text that will be displayed for additional field guidance.
         */
        "helperText": string;
        /**
          * If `true`, the label will be hidden and the required label value will be applied as an aria-label.
         */
        "hideLabel": boolean;
        /**
          * The label for the checkbox group to be displayed.
         */
        "label": string;
        /**
          * The name for the checkbox group to differentiate from other groups.
         */
        "name": string;
        /**
          * If `true`, the checkbox group will require a value.
         */
        "required": boolean;
        /**
          * The size of the checkboxes to be displayed. This does not affect the font size of the label.
         */
        "size"?: IcSizes;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small": boolean;
        /**
          * The validation status - e.g. 'error' | 'warning' | 'success'.
         */
        "validationStatus": IcInformationStatusOrEmpty;
        /**
          * The validation text - e.g. 'error' | 'warning' | 'success'.
         */
        "validationText": string;
    }
    interface IcChip {
        /**
          * @deprecated This prop should not be used anymore. Use variant prop instead.
         */
        "appearance"?: IcChipAppearance;
        /**
          * If `true`, the chip will appear disabled.
         */
        "disabled"?: boolean;
        /**
          * If `true`, the chip will have a close button at the end to dismiss it.
         */
        "dismissible"?: boolean;
        /**
          * The text rendered within the chip.
         */
        "label": string;
        /**
          * Sets focus on the chip.
         */
        "setFocus": () => Promise<void>;
        /**
          * The size of the chip.
         */
        "size"?: IcSizes;
        /**
          * If `true`, the outlined variant of chip will have a transparent background rather than white.
         */
        "transparentBackground"?: boolean;
        /**
          * The emphasis of the chip.
         */
        "variant"?: IcEmphasisType;
    }
    interface IcClassificationBanner {
        /**
          * The additional information that will be displayed after the classification.
         */
        "additionalSelectors"?: string;
        /**
          * The classification level to be displayed - also determines the banner and text colour.
         */
        "classification"?: IcProtectiveMarkings;
        /**
          * The optional text that will be displayed before classification to specify relevant country/countries.
         */
        "country"?: string;
        /**
          * If `true`, the banner will appear inline with the page, instead of sticking to the bottom of the page.
         */
        "inline"?: boolean;
        /**
          * If `true`, "Up to" will be displayed before the classification and country.
         */
        "upTo"?: boolean;
    }
    interface IcDataEntity {
        /**
          * The title for the data entity.
         */
        "heading": string;
        /**
          * The size of the data entity component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
    }
    interface IcDataRow {
        /**
          * The label in the leftmost cell of the row.
         */
        "label": string;
        /**
          * The size of the data row component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * The value of the middle (right if no end-component supplied) cell of the row.
         */
        "value": string;
    }
    interface IcDialog {
        /**
          * @deprecated This prop should not be used anymore. Use an ic-alert/IcAlert component within an alert slot with a heading instead.
         */
        "alertHeading"?: string;
        /**
          * @deprecated This prop should not be used anymore. Use an ic-alert/IcAlert component within an alert slot with a message instead.
         */
        "alertMessage"?: string;
        /**
          * Sets the label and onclick functions for default buttons.
         */
        "buttonProps"?: { label: string; onclick: string }[];
        /**
          * If set to `false`, dialog controls will not be displayed overriding buttonProps or slotted dialog controls.
         */
        "buttons"?: boolean;
        /**
          * Cancels the dialog. Used by the default 'Cancel' button or can be called manually to trigger cancelling of dialog.
         */
        "cancelDialog": () => Promise<void>;
        /**
          * If set to `true`, the dialog will not close when the backdrop is clicked.
         */
        "closeOnBackdropClick"?: boolean;
        /**
          * Confirms the dialog. Used by the default 'Confirm' button or can be called manually to trigger confirming of dialog.
         */
        "confirmDialog": () => Promise<void>;
        /**
          * If default buttons are displayed, sets the 'primary' or rightmost button to the destructive variant. Stops initial focus being set on the 'primary' or rightmost default or slotted button.
         */
        "destructive"?: boolean;
        /**
          * If set to `true`, the content area max height and overflow properties are removed allowing the dialog to stretch below the fold. This prop also prevents popover elements from being cut off within the content area.
         */
        "disableHeightConstraint"?: boolean;
        /**
          * If set to `true`, the content area width property is removed, allowing content to take the full width of the dialog when using the large variant.
         */
        "disableWidthConstraint"?: boolean;
        /**
          * Sets the dismiss label tooltip and aria label.
         */
        "dismissLabel"?: string;
        /**
          * Sets the heading for the dialog.
         */
        "heading": string;
        /**
          * If `true`, the close button will not be displayed.
         */
        "hideCloseButton"?: boolean;
        /**
          * @deprecated This method should not be used anymore. Use open prop to set dialog visibility.
         */
        "hideDialog": () => Promise<void>;
        /**
          * Sets the optional label for the dialog which appears above the heading.
         */
        "label"?: string;
        /**
          * If `true`, the dialog will be displayed.
         */
        "open": boolean;
        /**
          * @deprecated This method should not be used anymore. Use open prop to set dialog visibility.
         */
        "showDialog": () => Promise<void>;
        /**
          * Sets the maximum and minimum height and width for the dialog.
         */
        "size"?: "small" | "medium" | "large";
        /**
          * @deprecated This prop should not be used anymore. Use an ic-alert/IcAlert component within an alert slot with a variant instead.
         */
        "status"?: "neutral" | "info" | "warning" | "error" | "success";
    }
    interface IcDivider {
    }
    interface IcEmptyState {
        /**
          * The alignment of the empty state container.
         */
        "aligned"?: IcEmptyStateAlignment;
        /**
          * The body text rendered in the empty state container.
         */
        "body"?: string;
        /**
          * The number of lines of body text to display before truncating.
         */
        "bodyMaxLines"?: number;
        /**
          * The title rendered in the empty state container.
         */
        "heading"?: string;
        /**
          * The size of the image or icon used in the image slot.
         */
        "imageSize"?: IcSizes;
        /**
          * The subtitle rendered in the empty state container.
         */
        "subheading"?: string;
    }
    interface IcFooter {
        /**
          * The alignment of the section containers used within the footer.
         */
        "aligned"?: IcAlignment;
        /**
          * The screen size breakpoint at which to switch to the small layout.
         */
        "breakpoint"?: IcFooterBreakpoints;
        /**
          * The caption displayed at the bottom of the footer.
         */
        "caption": string;
        /**
          * If `true`, the footer will display the crown copyright at the bottom.
         */
        "copyright": boolean;
        /**
          * The description displayed at the top of the footer.
         */
        "description": string;
        /**
          * If `true`, the footer will be set up to handle link groups instead of standalone links.
         */
        "groupLinks"?: boolean;
    }
    interface IcFooterLink {
        /**
          * If `true`, the user can save the linked URL instead of navigating to it.
         */
        "download"?: string | boolean;
        /**
          * The URL that the link points to.
         */
        "href"?: string;
        /**
          * The human language of the linked URL.
         */
        "hreflang"?: string;
        /**
          * How much of the referrer to send when following the link.
         */
        "referrerpolicy"?: ReferrerPolicy;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string;
        /**
          * The place to display the linked URL, as the name for a browsing context (a tab, window, or iframe).
         */
        "target"?: string;
    }
    interface IcFooterLinkGroup {
        /**
          * The title of the link group to be displayed.
         */
        "groupTitle": string;
    }
    interface IcHero {
        /**
          * The alignment of the hero.
         */
        "aligned": IcAlignment;
        /**
          * The optional background image.
         */
        "backgroundImage"?: string;
        /**
          * The alignment of the hero content.
         */
        "contentAligned": IcHeroContentAlignments;
        /**
          * If `true`, the background image (if set) will not scroll using a parallax effect.
         */
        "disableBackgroundParallax"?: boolean;
        /**
          * The heading of the hero.
         */
        "heading": string;
        /**
          * The optional secondary heading, replaced by slotted right content.
         */
        "secondaryHeading"?: string;
        /**
          * The optional secondary subheading, replaced by slotted right content.
         */
        "secondarySubheading"?: string;
        /**
          * The size of the hero component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * The description for the hero.
         */
        "subheading"?: string;
    }
    interface IcHorizontalScroll {
        /**
          * The appearance of the horizontal scroll, e.g. dark, light or the default.
         */
        "appearance"?: IcThemeForeground;
        "focusTrigger"?: string;
        "scrollItemIntoView": (itemPosition: number) => Promise<void>;
    }
    interface IcInputComponentContainer {
        /**
          * The appearance of the input component container.
         */
        "appearance"?: "dark" | "default";
        /**
          * @deprecated This prop should not be used anymore. Set prop `appearance` to "dark" instead.
         */
        "dark"?: boolean;
        /**
          * If `true`, the disabled state will be set.
         */
        "disabled": boolean;
        /**
          * If `true`, the input component container will fill the width of the container it is in.
         */
        "fullWidth": boolean;
        /**
          * If `true`, the input component container will allow for multiple lines.
         */
        "multiLine": boolean;
        /**
          * If `true`, the readonly state will be set.
         */
        "readonly": boolean;
        /**
          * The size of the input component container component.
         */
        "size"?: IcSizes;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * If `true`, the validation will display inline.
         */
        "validationInline": boolean;
        /**
          * The validation status of the input component container - e.g. 'error' | 'warning' | 'success'.
         */
        "validationStatus": IcInformationStatusOrEmpty;
    }
    interface IcInputContainer {
        /**
          * If `true`, the disabled state will be set.
         */
        "disabled"?: boolean;
        /**
          * If `true`, the readonly state will be set.
         */
        "readonly"?: boolean;
    }
    interface IcInputLabel {
        /**
          * The appearance of the input label.
         */
        "appearance"?: "dark" | "default";
        /**
          * @deprecated This prop should not be used anymore. Set prop `appearance` to "dark" instead.
         */
        "dark"?: boolean;
        /**
          * If `true`, the disabled state will be set.
         */
        "disabled": boolean;
        /**
          * If `true`, the input label will display with error styling.
         */
        "error"?: boolean;
        /**
          * The ID of the form element the label is bound to.
         */
        "for": string;
        /**
          * The helper text that will be displayed.
         */
        "helperText": string;
        /**
          * The text content of the label.
         */
        "label": string;
        /**
          * If `true`, the readonly state will be set.
         */
        "readonly": boolean;
        /**
          * If `true`, the input label will require a value.
         */
        "required": boolean;
    }
    interface IcInputValidation {
        /**
          * The ARIA live mode to apply to the message.
         */
        "ariaLiveMode": IcAriaLiveModeVariants;
        /**
          * The ID of the form element the validation is bound to.
         */
        "for": string;
        /**
          * If `true`, the input validation will fill the width of the container.
         */
        "fullWidth": boolean;
        /**
          * The validation message to display.
         */
        "message": string;
        /**
          * The status of the validation - e.g. 'error' | 'warning' | 'success'.
         */
        "status": IcInformationStatusOrEmpty;
    }
    interface IcLink {
        /**
          * The appearance of the link, e.g. dark, light, or default.
         */
        "appearance"?: IcThemeForeground;
        /**
          * If `true`, the user can save the linked URL instead of navigating to it.
         */
        "download"?: string | boolean;
        /**
          * The URL that the link points to.
         */
        "href"?: string;
        /**
          * The human language of the linked URL.
         */
        "hreflang"?: string;
        /**
          * How much of the referrer to send when following the link.
         */
        "referrerpolicy"?: ReferrerPolicy;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string;
        /**
          * Sets focus on the link.
         */
        "setFocus": () => Promise<void>;
        /**
          * @deprecated This prop should not be used anymore. The 'open in new tab/window' icon will display automatically if target="_blank".
         */
        "showIcon"?: boolean;
        /**
          * The place to display the linked URL, as the name for a browsing context (a tab, window, or iframe).
         */
        "target"?: string;
    }
    interface IcLoadingIndicator {
        /**
          * The appearance of the loading indicator, e.g. dark or light.
         */
        "appearance"?: IcThemeForegroundNoDefault;
        /**
          * The description that will be set as the aria-label of the loading indicator when not using a visible label.
         */
        "description"?: string;
        /**
          * If `true`, when linear, the full-width variant (i.e. without a border radius) will be displayed.
         */
        "fullWidth"?: boolean;
        "innerLabel"?: number;
        /**
          * The label to be displayed beneath the loading indicator. Display a changing label by separating multiple messages with forward slashes.
         */
        "label"?: string;
        /**
          * The time in milliseconds before the label changes.
         */
        "labelDuration"?: number;
        /**
          * The maximum value that the progress value can take. Used to calculate the proportional width of the progress bar.
         */
        "max"?: number;
        /**
          * The minimum value that the progress value can take. Used to calculate the proportional width of the progress bar.
         */
        "min"?: number;
        /**
          * The current amount of progress made. If not provided, component acts as an indeterminate loading indicator.
         */
        "progress"?: number;
        /**
          * The size of the loading indicator.
         */
        "size"?: IcLoadingSizes;
        /**
          * The type of indicator, either linear or circular.
         */
        "type"?: IcLoadingTypes;
    }
    interface IcMenu {
        /**
          * Determines whether options manually set as values (by pressing 'Enter') when they receive focus using keyboard navigation.
         */
        "activationType"?: IcActivationTypes;
        /**
          * The reference to an anchor element the menu will position itself from when rendered.
         */
        "anchorEl": HTMLElement;
        "autoFocusOnSelected": boolean;
        /**
          * If `true`, the menu will fill the width of the container.
         */
        "fullWidth": boolean;
        "handleClickOpen": () => Promise<void>;
        /**
          * Used alongside activationType If menu is opened via keyboard navigation (i.e. Enter, ArrowUp or ArrowDown), emit optionSelect custom event.
          * @param event The keyboard event which is available when handleKeyboardOpen is invoked.
         */
        "handleKeyboardOpen": (event: KeyboardEvent) => Promise<void>;
        "handleSetFirstOption": () => Promise<void>;
        "initPopperJs": (anchor: HTMLElement) => Promise<void>;
        /**
          * The reference to the input element.
         */
        "inputEl": HTMLElement;
        /**
          * The label for the input element.
         */
        "inputLabel": string;
        /**
          * The custom name for the label field for IcMenuOption.
         */
        "labelField": string;
        /**
          * The ID of the menu.
         */
        "menuId": string;
        /**
          * If `true`, the menu will be displayed open.
         */
        "open": boolean;
        /**
          * The possible menu selection options.
         */
        "options": IcMenuOption[];
        "parentEl"?: HTMLElement;
        /**
          * Specify the mode search bar uses to search. `navigation` allows for quick lookups of a set of values, `query` allows for more general searches.
         */
        "searchMode"?: IcSearchBarSearchModes;
        "selectOnEnter"?: boolean;
        /**
          * The size of the menu component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * The value of the currently selected option.
         */
        "value": string;
        /**
          * The custom name for the value field for IcMenuOption.
         */
        "valueField": string;
    }
    interface IcMenuGroup {
        /**
          * The label to display as the title of the menu group.
         */
        "label"?: string;
    }
    interface IcMenuItem {
        /**
          * The description displayed in the menu item, below the label.
         */
        "description"?: string;
        /**
          * If `true`, the menu item will be in disabled state.
         */
        "disabled"?: boolean;
        /**
          * The URL that the link points to. This will render the menu item as an "a" tag.
         */
        "href"?: string;
        /**
          * The human language of the linked URL.
         */
        "hreflang"?: string;
        /**
          * The label describing the keyboard shortcut for a menu item's action.
         */
        "keyboardShortcut"?: string;
        /**
          * The label to display in the menu item.
         */
        "label": string;
        /**
          * How much of the referrer to send when following the link.
         */
        "referrerpolicy"?: ReferrerPolicy;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string;
        /**
          * This references the popover menu instance that the menu item is a trigger for. If this prop is set, then the variant will always be default.
         */
        "submenuTriggerFor"?: string;
        /**
          * The place to display the linked URL, as the name for a browsing context (a tab, window, or iframe).
         */
        "target"?: string;
        /**
          * The variant of the menu item.
         */
        "variant": IcMenuItemVariants;
    }
    interface IcNavigationButton {
        /**
          * If `true`, the user can save the linked URL instead of navigating to it.
         */
        "download"?: string | boolean;
        /**
          * The URL that the link points to. This will render the button as an "a" tag.
         */
        "href"?: string;
        /**
          * The human language of the linked URL.
         */
        "hreflang"?: string;
        /**
          * The label info to display.
         */
        "label": string;
        /**
          * How much of the referrer to send when following the link.
         */
        "referrerpolicy"?: ReferrerPolicy;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string;
        /**
          * Sets focus on the native `button`.
         */
        "setFocus": () => Promise<void>;
        /**
          * The place to display the linked URL, as the name for a browsing context (a tab, window, or iframe).
         */
        "target"?: string;
    }
    interface IcNavigationGroup {
        /**
          * If `true`, the group will be expandable in the side menu.
         */
        "expandable": boolean;
        /**
          * The label to display on the group.
         */
        "label": string;
        /**
          * Sets focus on the nav item.
         */
        "setFocus": () => Promise<void>;
    }
    interface IcNavigationItem {
        "collapsedIconLabel": boolean;
        "displayNavigationTooltip": boolean;
        /**
          * If `true`, the user can save the linked URL instead of navigating to it.
         */
        "download"?: string | boolean;
        "expandable": boolean;
        /**
          * The destination of the navigation item.
         */
        "href": string;
        /**
          * The human language of the linked URL.
         */
        "hreflang"?: string;
        /**
          * The label of the navigation item.
         */
        "label": string;
        /**
          * How much of the referrer to send when following the link.
         */
        "referrerpolicy"?: ReferrerPolicy;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string;
        /**
          * If `true`, the navigation item will be set in a selected state.
         */
        "selected": boolean;
        /**
          * Sets focus on the nav item.
         */
        "setFocus": () => Promise<void>;
        /**
          * The place to display the linked URL, as the name for a browsing context (a tab, window, or iframe).
         */
        "target"?: string;
    }
    interface IcNavigationMenu {
        /**
          * The status info to display.
         */
        "status": string;
        /**
          * The version info to display.
         */
        "version": string;
    }
    interface IcPageHeader {
        /**
          * The alignment of the page header.
         */
        "aligned"?: IcAlignment;
        /**
          * If `true`, a border will be displayed along the bottom of the page header.
         */
        "border"?: boolean;
        /**
          * The title to render on the page header.
         */
        "heading"?: string;
        /**
          * If `true`, the reading pattern and tab order will change in the action area for viewport widths of above 576px and when actions have not wrapped.
         */
        "reverseOrder"?: boolean;
        /**
          * The size of the page header component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * If `true`, the page header will be sticky at all breakpoints.
         */
        "sticky"?: boolean;
        /**
          * If `true`, the page header will only be sticky for viewport widths of 992px and above.
         */
        "stickyDesktopOnly"?: boolean;
        /**
          * The subtitle to render on the page header.
         */
        "subheading"?: string;
    }
    interface IcPagination {
        /**
          * The number of pages displayed adjacent to the current page when using 'complex' type pagination. Accepted values are 0, 1 & 2.
         */
        "adjacentCount": number;
        /**
          * The appearance of the pagination, e.g. dark, light or the default.
         */
        "appearance": IcThemeForeground;
        /**
          * The number of pages displayed as boundary items to the current page when using 'complex' type pagination. Accepted values are 0, 1 & 2.
         */
        "boundaryCount": number;
        /**
          * The current page displayed by the pagination.
         */
        "currentPage": number;
        /**
          * The default page to display.
         */
        "defaultPage": number;
        /**
          * If `true`, the pagination will not allow interaction.
         */
        "disabled": boolean;
        /**
          * If `true`, the current page of the simple pagination will not be displayed.
         */
        "hideCurrentPage": boolean;
        /**
          * If `true`, the first and last page buttons will not be displayed.
         */
        "hideFirstAndLastPageButton": boolean;
        /**
          * The label for the pagination item (applicable when simple pagination is being used).
         */
        "label": string;
        /**
          * The total number of pages.
         */
        "pages": number;
        /**
          * Sets the currently displayed page.
          * @param page The page number to set as the current page
         */
        "setCurrentPage": (page: number) => Promise<void>;
        /**
          * The type of pagination to be used.
         */
        "type": IcPaginationTypes;
    }
    interface IcPaginationItem {
        /**
          * The appearance of the pagination, e.g. dark, light or the default.
         */
        "appearance": IcThemeForeground;
        /**
          * If true the aria-label will be set to `Page X of Y`, where X is the current page and Y is the page count.
         */
        "ariaOverride": boolean;
        /**
          * If `true`, the pagination item will be disabled.
         */
        "disabled": boolean;
        /**
          * The label for the pagination item (applicable when simple pagination is being used).
         */
        "label": string;
        /**
          * The current page number.
         */
        "page": number | null;
        /**
          * The total number of pages.
         */
        "pages": number;
        /**
          * If `true`, the pagination item will be selected.
         */
        "selected": boolean;
        /**
          * The type of pagination item - 'page' or 'ellipsis'.
         */
        "type": IcPaginationItemType;
    }
    interface IcPopoverMenu {
        /**
          * The ID of the element the popover menu will anchor itself to. This is required unless the popover is a submenu.
         */
        "anchor": string;
        /**
          * If `true`, the popover menu will be displayed.
         */
        "open": boolean;
        "openFromChild": () => Promise<void>;
        "openFromParent": () => Promise<void>;
        "parentLabel"?: string;
        "parentPopover"?: HTMLIcPopoverMenuElement;
        /**
          * The unique identifier for a popover submenu.
         */
        "submenuId"?: string;
        "submenuLevel": number;
    }
    interface IcRadioGroup {
        /**
          * If `true`, the disabled state will be set.
         */
        "disabled": boolean;
        /**
          * The helper text that will be displayed for additional field guidance.
         */
        "helperText": string;
        /**
          * If `true`, the label will be hidden and the required label value will be applied as an aria-label.
         */
        "hideLabel": boolean;
        /**
          * The label for the radio group to be displayed.
         */
        "label": string;
        /**
          * The name for the radio group to differentiate from other groups.
         */
        "name": string;
        /**
          * The orientation of the radio buttons in the radio group. If there are more than two radio buttons in a radio group or either of the radio buttons use the `additional-field` slot, then the orientation will always be vertical.
         */
        "orientation": IcOrientation;
        /**
          * If `true`, the radio group will require a value.
         */
        "required": boolean;
        /**
          * The size of the radio group component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * The validation status - e.g. 'error' | 'warning' | 'success'.
         */
        "validationStatus": IcInformationStatusOrEmpty;
        /**
          * The validation text - e.g. 'error' | 'warning' | 'success'.
         */
        "validationText": string;
    }
    interface IcRadioOption {
        /**
          * The style of additionalField that will be displayed if used.
         */
        "additionalFieldDisplay": IcAdditionalFieldTypes;
        /**
          * If `true`, the disabled state will be set.
         */
        "disabled"?: boolean;
        /**
          * The text to be displayed when dynamic.
         */
        "dynamicText": string;
        /**
          * The <form> element to associate the radio with.
         */
        "form"?: string;
        /**
          * The URL that processes the information submitted by the radio. It overrides the action attribute of the radio's form owner. Does nothing if there is no form owner.
         */
        "formaction"?: string;
        /**
          * The way the submitted form data is encoded.
         */
        "formenctype"?: string;
        /**
          * The HTTP method used to submit the form.
         */
        "formmethod"?: string;
        /**
          * If `true`, the form will not be validated when submitted.
         */
        "formnovalidate"?: boolean;
        /**
          * The place to display the response from submitting the form. It overrides the target attribute of the radio's form owner.
         */
        "formtarget"?: string;
        /**
          * The group label for the radio option.
         */
        "groupLabel": string;
        /**
          * The label for the radio option.
         */
        "label"?: string;
        /**
          * The name for the radio option.
         */
        "name": string;
        /**
          * If `true`, the radio option will be displayed in a selected state.
         */
        "selected"?: boolean;
        /**
          * Sets focus on the radio option.
         */
        "setFocus": () => Promise<void>;
        /**
          * The value for the radio option.
         */
        "value": string;
    }
    interface IcSearchBar {
        /**
          * The automatic capitalisation of the text value as it is entered/edited by the user. Available options: "off", "none", "on", "sentences", "words", "characters".
         */
        "autocapitalize": string;
        /**
          * The state of autocompletion the browser can apply on the text value.
         */
        "autocomplete"?: IcAutocompleteTypes;
        /**
          * The state of autocorrection the browser can apply when the user is entering/editing the text value.
         */
        "autocorrect"?: IcAutocorrectStates;
        /**
          * If `true`, the form control will have input focus when the page loads.
         */
        "autofocus": boolean;
        /**
          * The number of characters until suggestions appear. The submit button will be disabled until the inputted value is equal to or greater than this number.
         */
        "charactersUntilSuggestion": number;
        /**
          * The amount of time, in milliseconds, to wait to trigger the `icChange` event after each keystroke.
         */
        "debounce"?: number;
        /**
          * Specify whether to disable the built in filtering. For example, if options will already be filtered from external source. If `true`, all options provided will be displayed.
         */
        "disableFilter"?: boolean;
        /**
          * If `true`, the disabled state will be set.
         */
        "disabled"?: boolean;
        /**
          * The text displayed when there are no options in the option list.
         */
        "emptyOptionListText": string;
        /**
          * If `true`, the search bar will be focused when component loaded.
         */
        "focusOnLoad"?: boolean;
        /**
          * Specify whether the search bar fills the full width of the container. If `true`, this overrides the --input-width CSS variable.
         */
        "fullWidth"?: boolean;
        /**
          * The helper text that will be displayed for additional field guidance.
         */
        "helperText"?: string;
        /**
          * If `true`, the label will be hidden and the required label value will be applied as an aria-label.
         */
        "hideLabel"?: boolean;
        /**
          * The hint text for the hidden assistive description element.
         */
        "hintText"?: string;
        /**
          * The label for the search bar.
         */
        "label": string;
        /**
          * The custom name for the label field to correspond with the IcMenuOption type.
         */
        "labelField"?: string;
        /**
          * Trigger loading state when fetching options asynchronously
         */
        "loading"?: boolean;
        /**
          * Change the message displayed when external loading times out.
         */
        "loadingErrorLabel"?: string;
        /**
          * Change the message displayed whilst the options are being loaded externally.
         */
        "loadingLabel"?: string;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name": string;
        /**
          * The suggested search options.
         */
        "options"?: IcMenuOption[];
        /**
          * The placeholder value to display.
         */
        "placeholder"?: string;
        /**
          * If `true`, the readonly state will be set.
         */
        "readonly"?: boolean;
        /**
          * If `true`, the search bar will require a value.
         */
        "required"?: boolean;
        /**
          * Specify the mode search bar uses to search. `navigation` allows for quick lookups of a set of values, `query` allows for more general searches.
         */
        "searchMode"?: IcSearchBarSearchModes;
        /**
          * Sets focus on the native `input`.
         */
        "setFocus": () => Promise<void>;
        /**
          * The size of the search bar component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * If `true`, the value of the search will have its spelling and grammar checked.
         */
        "spellcheck": boolean;
        /**
          * If using external filtering, set a timeout for when loading takes too long.
         */
        "timeout"?: number;
        /**
          * The value of the search input.
         */
        "value": string;
        /**
          * The custom name for the value field to correspond with the IcMenuOption type.
         */
        "valueField"?: string;
    }
    interface IcSectionContainer {
        /**
          * The alignment of the container.
         */
        "aligned"?: IcAlignment;
        /**
          * If `true`, the standard vertical padding from the container will be removed.
         */
        "fullHeight"?: boolean;
    }
    interface IcSelect {
        /**
          * @deprecated This prop should not be used anymore.
         */
        "charactersUntilSuggestions"?: number;
        /**
          * The amount of time, in milliseconds, to wait to trigger the `icChange` event after each keystroke.
         */
        "debounce"?: number;
        /**
          * If `true`, the built in filtering will be disabled for a searchable variant. For example, if options will already be filtered from external source.
         */
        "disableFilter"?: boolean;
        /**
          * If `true`, the disabled state will be set.
         */
        "disabled"?: boolean;
        /**
          * The text displayed when there are no options in the option list.
         */
        "emptyOptionListText": string;
        /**
          * The <form> element to associate the select with.
         */
        "form"?: string;
        /**
          * The URL that processes the information submitted by the select. It overrides the action attribute of the select's form owner. Does nothing if there is no form owner. This prop should only be used with searchable select and will only be applied if searchable is true.
         */
        "formaction"?: string;
        /**
          * The way the submitted form data is encoded. This prop should only be used with searchable select and will only be applied if searchable is true.
         */
        "formenctype"?: string;
        /**
          * The HTTP method used to submit the form. This prop should only be used with searchable select and will only be applied if searchable is true.
         */
        "formmethod"?: string;
        /**
          * If `true`, the form will not be validated when submitted. This prop should only be used with searchable select and will only be applied if searchable is true.
         */
        "formnovalidate"?: boolean;
        /**
          * The place to display the response from submitting the form. It overrides the target attribute of the select's form owner. This prop should only be used with searchable select and will only be applied if searchable is true.
         */
        "formtarget"?: string;
        /**
          * If `true`, the select element will fill the width of the container. This prop should only be used with searchable select and will only be applied if searchable is true.
         */
        "fullWidth": boolean;
        /**
          * The helper text that will be displayed for additional field guidance.
         */
        "helperText"?: string;
        /**
          * If `true`, the label will be hidden and the required label value will be applied as an aria-label.
         */
        "hideLabel"?: boolean;
        /**
          * If `true`, descriptions of options will be included when filtering options in a searchable select. Only applies to built in filtering.
         */
        "includeDescriptionsInSearch"?: boolean;
        /**
          * If `true`, group titles of grouped options will be included when filtering options in a searchable select. Only applies to built in filtering.
         */
        "includeGroupTitlesInSearch"?: boolean;
        /**
          * The label for the select.
         */
        "label": string;
        /**
          * If `true`, the loading state will be triggered when fetching options asynchronously.
         */
        "loading"?: boolean;
        /**
          * The message displayed when external loading times out.
         */
        "loadingErrorLabel"?: string;
        /**
          * The message displayed whilst the options are being loaded externally.
         */
        "loadingLabel"?: string;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * The possible selection options.
         */
        "options"?: IcMenuOption[];
        /**
          * The placeholder value to be displayed.
         */
        "placeholder"?: string;
        /**
          * If `true`, the readonly state will be set.
         */
        "readonly"?: boolean;
        /**
          * If `true`, the select will require a value.
         */
        "required"?: boolean;
        /**
          * Whether the search string of the searchable select should match the start of or anywhere in the options. Only applies to built in filtering.
         */
        "searchMatchPosition"?: IcSearchMatchPositions;
        /**
          * If `true`, a searchable variant of the select will be displayed which can be typed in to filter options.
         */
        "searchable"?: boolean;
        /**
          * If `true`, the icOptionSelect event will be fired on enter instead of ArrowUp and ArrowDown.
         */
        "selectOnEnter"?: boolean;
        /**
          * Sets focus on the input box.
         */
        "setFocus": () => Promise<void>;
        /**
          * If `true`, a button which clears the select input when clicked will be displayed. The button will always appear on the searchable select.
         */
        "showClearButton"?: boolean;
        /**
          * The size of the select component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * If using external filtering, set a timeout for when loading takes too long.
         */
        "timeout"?: number;
        /**
          * The validation status - e.g. 'error' | 'warning' | 'success'.
         */
        "validationStatus"?: IcInformationStatusOrEmpty;
        /**
          * The text to display as the validation message.
         */
        "validationText"?: string;
        /**
          * The value of the select, reflected by the value of the currently selected option. For the searchable variant, the value is also reflected by the user input.
         */
        "value"?: string;
    }
    interface IcSideNavigation {
        /**
          * The app title to be displayed. This is required, unless a slotted app title link is used.
         */
        "appTitle": string;
        /**
          * If `true`, the icon and label will appear when side navigation is collapsed.
         */
        "collapsedIconLabels": boolean;
        /**
          * If `true`, automatic parent wrapper styling will be disabled.
         */
        "disableAutoParentStyling": boolean;
        /**
          * If `true`, the side navigation will not display as a top bar on small devices.
         */
        "disableTopBarBehaviour": boolean;
        /**
          * If `true`, the side navigation will display in an expanded state.
         */
        "expanded": boolean;
        /**
          * The URL that the app title link points to.
         */
        "href": string;
        "inline": boolean;
        /**
          * The short title of the app to be displayed at small screen sizes in place of the app title.
         */
        "shortAppTitle": string;
        /**
          * If `true`, the menu expand button will be removed (PLEASE NOTE: This takes effect on screen sizes 992px and above).
         */
        "static": boolean;
        /**
          * The status of the app to be displayed.
         */
        "status": string;
        /**
          * The version of the app to be displayed.
         */
        "version": string;
    }
    interface IcSkeleton {
        /**
          * The appearance of the skeleton.
         */
        "appearance"?: "light" | "default";
        /**
          * @deprecated This prop should not be used anymore. Set prop `appearance` to "light" instead.
         */
        "light"?: boolean;
        /**
          * The variant of the skeleton that will be displayed.
         */
        "variant"?: IcSkeletonVariants;
    }
    interface IcStatusTag {
        /**
          * If `true`, role='status' is added to the component and it will act as an 'aria-live' region.
         */
        "announced"?: boolean;
        /**
          * @deprecated This prop should not be used anymore. Use variant prop instead.
         */
        "appearance"?: IcStatusTagAppearance;
        /**
          * The content rendered within the status tag.
         */
        "label": string;
        /**
          * The size of the status tag component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * The colour of the status tag.
         */
        "status"?: IcStatusTagStatuses;
        /**
          * The emphasis of the status tag.
         */
        "variant"?: IcEmphasisType;
    }
    interface IcStep {
        "compactStepStyling"?: IcStepTypes;
        "current"?: boolean;
        "lastStep": boolean;
        "lastStepNum"?: number;
        "nextStepTitle"?: string;
        "progress"?: number;
        "stepNum"?: number;
        /**
          * The status of the step. Use this prop to display a status message on the step if it is required or optional.
         */
        "stepStatus"?: IcStepStatuses;
        /**
          * Additional information about the step. Use this prop to override the default step status messaging displayed when selecting a step type or step status.
         */
        "stepSubtitle"?: string;
        /**
          * The title of the step within the stepper.
         */
        "stepTitle"?: string;
        /**
          * The state of the step within the stepper.
         */
        "stepType"?: IcStepTypes;
        "variant": IcStepVariants;
    }
    interface IcStepper {
        /**
          * The alignment of the default stepper within its container.
         */
        "aligned"?: IcStepperAlignment;
        /**
          * The length of the connnector between each step in pixels. Minimum length is 100px.
         */
        "connectorWidth"?: number;
        /**
          * If `true`, the information about each step, i.e. step title, step subtitle and step status, will be hidden on all default steps. The information about each step will still be visible in the compact variant of the stepper.
         */
        "hideStepInfo"?: boolean;
        /**
          * The variant of the stepper.
         */
        "variant"?: IcStepVariants;
    }
    interface IcSwitch {
        /**
          * If `true`, the switch will display as checked.
         */
        "checked"?: boolean;
        /**
          * If `true`, the disabled state will be set.
         */
        "disabled"?: boolean;
        /**
          * The helper text that will be displayed for additional field guidance.
         */
        "helperText"?: string;
        /**
          * If `true`, the label will be hidden and the required label value will be applied as an aria-label.
         */
        "hideLabel"?: boolean;
        /**
          * The aria-label applied to the switch when no visual 'name' is provided.
         */
        "label": string;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Sets focus on the switch.
         */
        "setFocus": () => Promise<void>;
        /**
          * If `true`, the switch will render the On/Off state text.
         */
        "showState"?: boolean;
        /**
          * The size of the switch component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * The value of the toggle does not mean if it's checked or not, use the `checked` property for that.  The value of a toggle is analogous to the value of a `<input type="checkbox">`, it's only used when the toggle participates in a native `<form>`.
         */
        "value"?: string | null;
    }
    interface IcTab {
        "appearance"?: IcThemeForegroundNoDefault;
        "contextId"?: string;
        /**
          * If `true`, the disabled state will be set.
         */
        "disabled"?: boolean;
        "selected"?: boolean;
        /**
          * Sets focus on the tab.
         */
        "setFocus": () => Promise<void>;
        "tabId"?: string;
        "tabPosition"?: number;
    }
    interface IcTabContext {
        /**
          * Determines whether tabs have to be manually activated (by pressing 'Enter' or 'Space') when they receive focus using keyboard navigation.
         */
        "activationType"?: IcActivationTypes;
        /**
          * The appearance of the tab context, e.g dark, or light.
         */
        "appearance"?: IcThemeForegroundNoDefault;
        /**
          * The unique context needed if using multiple tabs inside one another i.e. rendering another set of tabs inside a tab panel.
         */
        "contextId"?: string;
        /**
          * The selected tab to be controlled by the user. Must be used alongside the icTabSelect event to manage tab selection.
         */
        "selectedTabIndex"?: number;
        "tabRemovedHandler": (hadFocus?: boolean) => Promise<void>;
    }
    interface IcTabGroup {
        "appearance"?: IcThemeForegroundNoDefault;
        /**
          * @deprecated This is no longer required. The context id is passed down from `ic-tab-context`
         */
        "contextId"?: string;
        /**
          * If `true`, the tabs and tab panels will be positioned separately.
         */
        "inline"?: boolean;
        /**
          * The label to describe the purpose of the set of tabs to screen reader users.
         */
        "label": string;
    }
    interface IcTabPanel {
        "appearance"?: IcThemeForegroundNoDefault;
        /**
          * @deprecated This is no longer required. The context id is passed down from `ic-tab-context`
         */
        "contextId"?: string;
        "panelId"?: string;
        "selectedTab"?: string;
        "tabPosition"?: number;
    }
    interface IcTextField {
        "ariaActiveDescendant"?: string;
        "ariaAutocomplete": IcAriaAutocompleteTypes;
        "ariaExpanded": string;
        "ariaOwns": string;
        /**
          * If `true`, the form control will have input focus when the page loads.
         */
        "autoFocus": boolean;
        /**
          * The automatic capitalisation of the text value as it is entered/edited by the user. Available options: "off", "none", "on", "sentences", "words", "characters".
         */
        "autocapitalize": string;
        /**
          * The state of autocompletion the browser can apply on the text value.
         */
        "autocomplete": IcAutocompleteTypes;
        /**
          * The state of autocorrection the browser can apply when the user is entering/editing the text value.
         */
        "autocorrect": IcAutocorrectStates;
        /**
          * The amount of time, in milliseconds, to wait to trigger the `icChange` event after each keystroke.
         */
        "debounce": number;
        /**
          * If `true`, the disabled state will be set.
         */
        "disabled": boolean;
        /**
          * Specify whether the text field fills the full width of the container. If `true`, this overrides the --input-width CSS variable.
         */
        "fullWidth": boolean;
        /**
          * The helper text that will be displayed for additional field guidance.
         */
        "helperText": string;
        "hiddenInput": boolean;
        /**
          * If `true`, the label will be hidden and the required label value will be applied as an aria-label.
         */
        "hideLabel": boolean;
        /**
          * The ID for the input.
         */
        "inputId"?: string;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode": IcTextFieldInputModes;
        /**
          * The label for the input.
         */
        "label": string;
        /**
          * The maximum number that can be accepted as a value, when `type` is `number` and `rows` is `1`. (NOTE: Ensure to include visual indication of max value in `helperText` or `label`)
         */
        "max": string | number;
        /**
          * The maximum number of characters that can be entered in the field.
         */
        "maxCharacters": number;
        /**
          * The label for maximum number of characters that can be entered in the field.
         */
        "maxLength": number;
        /**
          * The minimum number that can be accepted as a value, when `type` is `number` and `rows` is `1`. (NOTE: Ensure to include visual indication of min value in `helperText` or `label`)
         */
        "min": string | number;
        /**
          * The minimum number of characters that can be entered in the field.
         */
        "minCharacters": number;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name": string;
        /**
          * The placeholder value to be displayed.
         */
        "placeholder": string;
        /**
          * If `true`, the read only state will be set.
         */
        "readonly": boolean;
        /**
          * If `true`, the input will require a value.
         */
        "required": boolean;
        /**
          * If `true`, the multiline text area will be resizeable.
         */
        "resize": boolean;
        "role": string;
        /**
          * The number of rows to transform the text field into a text area with a specific height.
         */
        "rows": number;
        /**
          * Sets focus on the native `input`.
         */
        "setFocus": () => Promise<void>;
        /**
          * The size of the text field component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * If `true`, the value of the text field will have its spelling and grammar checked.
         */
        "spellcheck": boolean;
        "truncateValue"?: boolean;
        /**
          * The type of control to display. The default type is text.
         */
        "type": IcTextFieldTypes;
        /**
          * If `true`, the icon in input control will be displayed - only applies when validationStatus ='success'.
         */
        "validationInline": boolean;
        "validationInlineInternal": boolean;
        /**
          * The validation state - e.g. 'error' | 'warning' | 'success'.
         */
        "validationStatus": IcInformationStatusOrEmpty;
        /**
          * The validation state - e.g. 'error' | 'warning' | 'success'.
         */
        "validationText": string;
        /**
          * The value of the text field.
         */
        "value": string;
    }
    interface IcTheme {
        /**
          * The theme colour. Can be a hex value e.g. "#ff0000", RGB e.g. "rgb(255, 0, 0)", or RGBA e.g. "rgba(255, 0, 0, 1)".
         */
        "color"?: string;
    }
    interface IcToast {
        /**
          * If toast dismissMode is set to `automatic`, use this prop to define the time before the toast dismisses (in MILLISECONDS) (NOTE: Has a minimum value of `5000ms`)
         */
        "autoDismissTimeout"?: number;
        /**
          * If toast can be manually dismissed, this prop sets a custom aria-label for the ic-button component
         */
        "dismissButtonAriaLabel"?: string;
        /**
          * How the toast will be dismissed. If manual will display a dismiss button.
         */
        "dismissMode"?: IcActivationTypes;
        /**
          * The title to display at the start of the toast. (NOTE: Should be no more than `70` characters)
         */
        "heading": string;
        /**
          * The main body message of the toast. (NOTE: Should be no more than `140` characters)
         */
        "message"?: string;
        /**
          * Provides a custom alt-text to be announced to screen readers, if slotting a custom neutral icon
         */
        "neutralIconAriaLabel"?: string;
        /**
          * @returns The element that previously had focus before the toast appeared
         */
        "setVisible": () => Promise<HTMLElement>;
        /**
          * The variant of the toast being rendered
         */
        "variant"?: IcStatusVariants;
    }
    interface IcToastRegion {
        /**
          * The toast element to be displayed.
         */
        "openToast": HTMLIcToastElement;
        /**
          * @deprecated Use openToast prop to display toast instead.
          * @param toast The toast component to display
         */
        "setVisible": (toast: HTMLIcToastElement) => Promise<void>;
    }
    interface IcToggleButton {
        /**
          * The accessible label that will be applied to the toggle button. This is required for the icon variant of toggle buttons.
         */
        "accessibleLabel"?: string;
        /**
          * The appearance of the toggle button.
         */
        "appearance"?: IcThemeForeground;
        /**
          * If `true`, the toggle button will be in disabled state.
         */
        "disabled"?: boolean;
        /**
          * If `true`, the toggle button will fill the width of the container.
         */
        "fullWidth"?: boolean;
        /**
          * The placement of the icon in relation to the toggle button label.
         */
        "iconPlacement"?: "left" | "right" | "top";
        /**
          * The label to display in the toggle button. This is required for the default variant of toggle buttons.
         */
        "label"?: string;
        /**
          * If `true`, the toggle button will be in loading state.
         */
        "loading"?: boolean;
        /**
          * The size of the toggle button to be displayed.
         */
        "size"?: IcSizes;
        /**
          * If `true`, the toggle button will be in a checked state.
         */
        "toggleChecked": boolean;
        /**
          * The variant of the toggle button.
         */
        "variant": "default" | "icon";
    }
    interface IcTooltip {
        "disableClick"?: boolean;
        /**
          * If `true`, the tooltip will not be displayed on hover, it will require a click.
         */
        "disableHover"?: boolean;
        /**
          * Method to programmatically show/hide the tooltip without needing to interact with an anchor element
          * @param show Whether to show or hide the tooltip
          * @param persistTooltip Whether the tooltip should stay on the screen when actions are performed that would previously dismiss the tooltip, such as on hover
         */
        "displayTooltip": (show: boolean, persistTooltip?: boolean) => Promise<void>;
        /**
          * The text to display on the tooltip.
         */
        "label": string;
        /**
          * The number of lines to display before truncating the text.
         */
        "maxLines"?: number;
        /**
          * The position of the tooltip in relation to the parent element.
         */
        "placement"?: IcTooltipPlacements;
        "silent"?: boolean;
        /**
          * The ID of the element the tooltip is describing - for when aria-labelledby or aria-describedby is used.
         */
        "target"?: string;
    }
    interface IcTopNavigation {
        /**
          * The app title to be displayed. This is required, unless a slotted app title link is used.
         */
        "appTitle": string;
        /**
          * The alignment of the top navigation content.
         */
        "contentAligned": IcAlignment;
        /**
          * The URL to navigate to when the app title is clicked.
         */
        "href": string;
        /**
          * If `true`, the flyout navigation menu on small devices will be contained by the parent element.
         */
        "inline": boolean;
        /**
          * The short title of the app to be displayed at small screen sizes in place of the app title.
         */
        "shortAppTitle": string;
        /**
          * The status info to be displayed.
         */
        "status": string;
        /**
          * The version info to be displayed.
         */
        "version": string;
    }
    interface IcTypography {
        /**
          * If `true`, appropriate top and bottom margins will be applied to the typography.
         */
        "applyVerticalMargins"?: boolean;
        /**
          * If `true`, the typography will have a bold font weight. Note: This will have no impact on variants that already use an equivalent or higher font weight (h1, h2, and subtitle-large).
         */
        "bold"?: boolean;
        /**
          * If `true`, the typography will have an italic font style.
         */
        "italic"?: boolean;
        /**
          * The number of lines to display before truncating the text, only used for the 'body' variant.
         */
        "maxLines"?: number;
        /**
          * If `true`, the typography will have a line through it.
         */
        "strikethrough"?: boolean;
        /**
          * If `true`, the typography will have a line under it.
         */
        "underline"?: boolean;
        /**
          * The ICDS typography style to use.
         */
        "variant"?: IcTypographyVariants;
    }
}
export interface IcAccordionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcAccordionElement;
}
export interface IcAlertCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcAlertElement;
}
export interface IcButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcButtonElement;
}
export interface IcCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcCheckboxElement;
}
export interface IcCheckboxGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcCheckboxGroupElement;
}
export interface IcChipCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcChipElement;
}
export interface IcDialogCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcDialogElement;
}
export interface IcFooterCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcFooterElement;
}
export interface IcMenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcMenuElement;
}
export interface IcMenuItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcMenuItemElement;
}
export interface IcNavigationItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcNavigationItemElement;
}
export interface IcNavigationMenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcNavigationMenuElement;
}
export interface IcPaginationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcPaginationElement;
}
export interface IcPaginationItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcPaginationItemElement;
}
export interface IcPopoverMenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcPopoverMenuElement;
}
export interface IcRadioGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcRadioGroupElement;
}
export interface IcRadioOptionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcRadioOptionElement;
}
export interface IcSearchBarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcSearchBarElement;
}
export interface IcSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcSelectElement;
}
export interface IcSideNavigationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcSideNavigationElement;
}
export interface IcSwitchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcSwitchElement;
}
export interface IcTabCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcTabElement;
}
export interface IcTabContextCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcTabContextElement;
}
export interface IcTabPanelCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcTabPanelElement;
}
export interface IcTextFieldCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcTextFieldElement;
}
export interface IcThemeCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcThemeElement;
}
export interface IcToastCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcToastElement;
}
export interface IcToggleButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcToggleButtonElement;
}
export interface IcTopNavigationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIcTopNavigationElement;
}
declare global {
    interface HTMLIcAccordionElementEventMap {
        "accordionClicked": { id: string };
    }
    interface HTMLIcAccordionElement extends Components.IcAccordion, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcAccordionElementEventMap>(type: K, listener: (this: HTMLIcAccordionElement, ev: IcAccordionCustomEvent<HTMLIcAccordionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcAccordionElementEventMap>(type: K, listener: (this: HTMLIcAccordionElement, ev: IcAccordionCustomEvent<HTMLIcAccordionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcAccordionElement: {
        prototype: HTMLIcAccordionElement;
        new (): HTMLIcAccordionElement;
    };
    interface HTMLIcAccordionGroupElement extends Components.IcAccordionGroup, HTMLStencilElement {
    }
    var HTMLIcAccordionGroupElement: {
        prototype: HTMLIcAccordionGroupElement;
        new (): HTMLIcAccordionGroupElement;
    };
    interface HTMLIcAlertElementEventMap {
        "dismiss": void;
        "icDismiss": void;
    }
    interface HTMLIcAlertElement extends Components.IcAlert, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcAlertElementEventMap>(type: K, listener: (this: HTMLIcAlertElement, ev: IcAlertCustomEvent<HTMLIcAlertElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcAlertElementEventMap>(type: K, listener: (this: HTMLIcAlertElement, ev: IcAlertCustomEvent<HTMLIcAlertElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcAlertElement: {
        prototype: HTMLIcAlertElement;
        new (): HTMLIcAlertElement;
    };
    interface HTMLIcBackToTopElement extends Components.IcBackToTop, HTMLStencilElement {
    }
    var HTMLIcBackToTopElement: {
        prototype: HTMLIcBackToTopElement;
        new (): HTMLIcBackToTopElement;
    };
    interface HTMLIcBadgeElement extends Components.IcBadge, HTMLStencilElement {
    }
    var HTMLIcBadgeElement: {
        prototype: HTMLIcBadgeElement;
        new (): HTMLIcBadgeElement;
    };
    interface HTMLIcBreadcrumbElement extends Components.IcBreadcrumb, HTMLStencilElement {
    }
    var HTMLIcBreadcrumbElement: {
        prototype: HTMLIcBreadcrumbElement;
        new (): HTMLIcBreadcrumbElement;
    };
    interface HTMLIcBreadcrumbGroupElement extends Components.IcBreadcrumbGroup, HTMLStencilElement {
    }
    var HTMLIcBreadcrumbGroupElement: {
        prototype: HTMLIcBreadcrumbGroupElement;
        new (): HTMLIcBreadcrumbGroupElement;
    };
    interface HTMLIcButtonElementEventMap {
        "icBlur": void;
        "icFileSelection": FileList;
        "icFocus": void;
    }
    interface HTMLIcButtonElement extends Components.IcButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcButtonElementEventMap>(type: K, listener: (this: HTMLIcButtonElement, ev: IcButtonCustomEvent<HTMLIcButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcButtonElementEventMap>(type: K, listener: (this: HTMLIcButtonElement, ev: IcButtonCustomEvent<HTMLIcButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcButtonElement: {
        prototype: HTMLIcButtonElement;
        new (): HTMLIcButtonElement;
    };
    interface HTMLIcCardElement extends Components.IcCard, HTMLStencilElement {
    }
    var HTMLIcCardElement: {
        prototype: HTMLIcCardElement;
        new (): HTMLIcCardElement;
    };
    interface HTMLIcCheckboxElementEventMap {
        "checkboxChecked": void;
        "icCheck": void;
    }
    interface HTMLIcCheckboxElement extends Components.IcCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcCheckboxElementEventMap>(type: K, listener: (this: HTMLIcCheckboxElement, ev: IcCheckboxCustomEvent<HTMLIcCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcCheckboxElementEventMap>(type: K, listener: (this: HTMLIcCheckboxElement, ev: IcCheckboxCustomEvent<HTMLIcCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcCheckboxElement: {
        prototype: HTMLIcCheckboxElement;
        new (): HTMLIcCheckboxElement;
    };
    interface HTMLIcCheckboxGroupElementEventMap {
        "icChange": IcChangeEventDetail;
    }
    interface HTMLIcCheckboxGroupElement extends Components.IcCheckboxGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcCheckboxGroupElementEventMap>(type: K, listener: (this: HTMLIcCheckboxGroupElement, ev: IcCheckboxGroupCustomEvent<HTMLIcCheckboxGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcCheckboxGroupElementEventMap>(type: K, listener: (this: HTMLIcCheckboxGroupElement, ev: IcCheckboxGroupCustomEvent<HTMLIcCheckboxGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcCheckboxGroupElement: {
        prototype: HTMLIcCheckboxGroupElement;
        new (): HTMLIcCheckboxGroupElement;
    };
    interface HTMLIcChipElementEventMap {
        "dismiss": void;
        "icDismiss": void;
    }
    interface HTMLIcChipElement extends Components.IcChip, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcChipElementEventMap>(type: K, listener: (this: HTMLIcChipElement, ev: IcChipCustomEvent<HTMLIcChipElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcChipElementEventMap>(type: K, listener: (this: HTMLIcChipElement, ev: IcChipCustomEvent<HTMLIcChipElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcChipElement: {
        prototype: HTMLIcChipElement;
        new (): HTMLIcChipElement;
    };
    interface HTMLIcClassificationBannerElement extends Components.IcClassificationBanner, HTMLStencilElement {
    }
    var HTMLIcClassificationBannerElement: {
        prototype: HTMLIcClassificationBannerElement;
        new (): HTMLIcClassificationBannerElement;
    };
    interface HTMLIcDataEntityElement extends Components.IcDataEntity, HTMLStencilElement {
    }
    var HTMLIcDataEntityElement: {
        prototype: HTMLIcDataEntityElement;
        new (): HTMLIcDataEntityElement;
    };
    interface HTMLIcDataRowElement extends Components.IcDataRow, HTMLStencilElement {
    }
    var HTMLIcDataRowElement: {
        prototype: HTMLIcDataRowElement;
        new (): HTMLIcDataRowElement;
    };
    interface HTMLIcDialogElementEventMap {
        "icDialogCancelled": void;
        "icDialogClosed": void;
        "icDialogConfirmed": void;
        "icDialogOpened": void;
    }
    interface HTMLIcDialogElement extends Components.IcDialog, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcDialogElementEventMap>(type: K, listener: (this: HTMLIcDialogElement, ev: IcDialogCustomEvent<HTMLIcDialogElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcDialogElementEventMap>(type: K, listener: (this: HTMLIcDialogElement, ev: IcDialogCustomEvent<HTMLIcDialogElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcDialogElement: {
        prototype: HTMLIcDialogElement;
        new (): HTMLIcDialogElement;
    };
    interface HTMLIcDividerElement extends Components.IcDivider, HTMLStencilElement {
    }
    var HTMLIcDividerElement: {
        prototype: HTMLIcDividerElement;
        new (): HTMLIcDividerElement;
    };
    interface HTMLIcEmptyStateElement extends Components.IcEmptyState, HTMLStencilElement {
    }
    var HTMLIcEmptyStateElement: {
        prototype: HTMLIcEmptyStateElement;
        new (): HTMLIcEmptyStateElement;
    };
    interface HTMLIcFooterElementEventMap {
        "footerResized": void;
    }
    interface HTMLIcFooterElement extends Components.IcFooter, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcFooterElementEventMap>(type: K, listener: (this: HTMLIcFooterElement, ev: IcFooterCustomEvent<HTMLIcFooterElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcFooterElementEventMap>(type: K, listener: (this: HTMLIcFooterElement, ev: IcFooterCustomEvent<HTMLIcFooterElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcFooterElement: {
        prototype: HTMLIcFooterElement;
        new (): HTMLIcFooterElement;
    };
    interface HTMLIcFooterLinkElement extends Components.IcFooterLink, HTMLStencilElement {
    }
    var HTMLIcFooterLinkElement: {
        prototype: HTMLIcFooterLinkElement;
        new (): HTMLIcFooterLinkElement;
    };
    interface HTMLIcFooterLinkGroupElement extends Components.IcFooterLinkGroup, HTMLStencilElement {
    }
    var HTMLIcFooterLinkGroupElement: {
        prototype: HTMLIcFooterLinkGroupElement;
        new (): HTMLIcFooterLinkGroupElement;
    };
    interface HTMLIcHeroElement extends Components.IcHero, HTMLStencilElement {
    }
    var HTMLIcHeroElement: {
        prototype: HTMLIcHeroElement;
        new (): HTMLIcHeroElement;
    };
    interface HTMLIcHorizontalScrollElement extends Components.IcHorizontalScroll, HTMLStencilElement {
    }
    var HTMLIcHorizontalScrollElement: {
        prototype: HTMLIcHorizontalScrollElement;
        new (): HTMLIcHorizontalScrollElement;
    };
    interface HTMLIcInputComponentContainerElement extends Components.IcInputComponentContainer, HTMLStencilElement {
    }
    var HTMLIcInputComponentContainerElement: {
        prototype: HTMLIcInputComponentContainerElement;
        new (): HTMLIcInputComponentContainerElement;
    };
    interface HTMLIcInputContainerElement extends Components.IcInputContainer, HTMLStencilElement {
    }
    var HTMLIcInputContainerElement: {
        prototype: HTMLIcInputContainerElement;
        new (): HTMLIcInputContainerElement;
    };
    interface HTMLIcInputLabelElement extends Components.IcInputLabel, HTMLStencilElement {
    }
    var HTMLIcInputLabelElement: {
        prototype: HTMLIcInputLabelElement;
        new (): HTMLIcInputLabelElement;
    };
    interface HTMLIcInputValidationElement extends Components.IcInputValidation, HTMLStencilElement {
    }
    var HTMLIcInputValidationElement: {
        prototype: HTMLIcInputValidationElement;
        new (): HTMLIcInputValidationElement;
    };
    interface HTMLIcLinkElement extends Components.IcLink, HTMLStencilElement {
    }
    var HTMLIcLinkElement: {
        prototype: HTMLIcLinkElement;
        new (): HTMLIcLinkElement;
    };
    interface HTMLIcLoadingIndicatorElement extends Components.IcLoadingIndicator, HTMLStencilElement {
    }
    var HTMLIcLoadingIndicatorElement: {
        prototype: HTMLIcLoadingIndicatorElement;
        new (): HTMLIcLoadingIndicatorElement;
    };
    interface HTMLIcMenuElementEventMap {
        "menuKeyPress": { isNavKey: boolean; key: string };
        "menuOptionId": IcMenuOptionIdEventDetail;
        "menuOptionSelect": IcOptionSelectEventDetail;
        "menuStateChange": IcMenuChangeEventDetail;
        "menuValueChange": IcValueEventDetail;
        "retryButtonClicked": IcValueEventDetail;
        "timeoutBlur": { ev: FocusEvent };
        "ungroupedOptionsSet": { options: IcMenuOption[] };
    }
    interface HTMLIcMenuElement extends Components.IcMenu, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcMenuElementEventMap>(type: K, listener: (this: HTMLIcMenuElement, ev: IcMenuCustomEvent<HTMLIcMenuElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcMenuElementEventMap>(type: K, listener: (this: HTMLIcMenuElement, ev: IcMenuCustomEvent<HTMLIcMenuElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcMenuElement: {
        prototype: HTMLIcMenuElement;
        new (): HTMLIcMenuElement;
    };
    interface HTMLIcMenuGroupElement extends Components.IcMenuGroup, HTMLStencilElement {
    }
    var HTMLIcMenuGroupElement: {
        prototype: HTMLIcMenuGroupElement;
        new (): HTMLIcMenuGroupElement;
    };
    interface HTMLIcMenuItemElementEventMap {
        "childBlur": void;
        "handleMenuItemClick": {
    label: string;
    hasSubMenu: boolean;
  };
        "triggerPopoverMenuInstance": void;
    }
    interface HTMLIcMenuItemElement extends Components.IcMenuItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcMenuItemElementEventMap>(type: K, listener: (this: HTMLIcMenuItemElement, ev: IcMenuItemCustomEvent<HTMLIcMenuItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcMenuItemElementEventMap>(type: K, listener: (this: HTMLIcMenuItemElement, ev: IcMenuItemCustomEvent<HTMLIcMenuItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcMenuItemElement: {
        prototype: HTMLIcMenuItemElement;
        new (): HTMLIcMenuItemElement;
    };
    interface HTMLIcNavigationButtonElement extends Components.IcNavigationButton, HTMLStencilElement {
    }
    var HTMLIcNavigationButtonElement: {
        prototype: HTMLIcNavigationButtonElement;
        new (): HTMLIcNavigationButtonElement;
    };
    interface HTMLIcNavigationGroupElement extends Components.IcNavigationGroup, HTMLStencilElement {
    }
    var HTMLIcNavigationGroupElement: {
        prototype: HTMLIcNavigationGroupElement;
        new (): HTMLIcNavigationGroupElement;
    };
    interface HTMLIcNavigationItemElementEventMap {
        "childBlur": void;
        "navItemClicked": void;
    }
    interface HTMLIcNavigationItemElement extends Components.IcNavigationItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcNavigationItemElementEventMap>(type: K, listener: (this: HTMLIcNavigationItemElement, ev: IcNavigationItemCustomEvent<HTMLIcNavigationItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcNavigationItemElementEventMap>(type: K, listener: (this: HTMLIcNavigationItemElement, ev: IcNavigationItemCustomEvent<HTMLIcNavigationItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcNavigationItemElement: {
        prototype: HTMLIcNavigationItemElement;
        new (): HTMLIcNavigationItemElement;
    };
    interface HTMLIcNavigationMenuElementEventMap {
        "icNavigationMenuClose": void;
    }
    interface HTMLIcNavigationMenuElement extends Components.IcNavigationMenu, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcNavigationMenuElementEventMap>(type: K, listener: (this: HTMLIcNavigationMenuElement, ev: IcNavigationMenuCustomEvent<HTMLIcNavigationMenuElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcNavigationMenuElementEventMap>(type: K, listener: (this: HTMLIcNavigationMenuElement, ev: IcNavigationMenuCustomEvent<HTMLIcNavigationMenuElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcNavigationMenuElement: {
        prototype: HTMLIcNavigationMenuElement;
        new (): HTMLIcNavigationMenuElement;
    };
    interface HTMLIcPageHeaderElement extends Components.IcPageHeader, HTMLStencilElement {
    }
    var HTMLIcPageHeaderElement: {
        prototype: HTMLIcPageHeaderElement;
        new (): HTMLIcPageHeaderElement;
    };
    interface HTMLIcPaginationElementEventMap {
        "icPageChange": IcChangeEventDetail1;
    }
    interface HTMLIcPaginationElement extends Components.IcPagination, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcPaginationElementEventMap>(type: K, listener: (this: HTMLIcPaginationElement, ev: IcPaginationCustomEvent<HTMLIcPaginationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcPaginationElementEventMap>(type: K, listener: (this: HTMLIcPaginationElement, ev: IcPaginationCustomEvent<HTMLIcPaginationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcPaginationElement: {
        prototype: HTMLIcPaginationElement;
        new (): HTMLIcPaginationElement;
    };
    interface HTMLIcPaginationItemElementEventMap {
        "paginationItemClick": { page: number };
    }
    interface HTMLIcPaginationItemElement extends Components.IcPaginationItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcPaginationItemElementEventMap>(type: K, listener: (this: HTMLIcPaginationItemElement, ev: IcPaginationItemCustomEvent<HTMLIcPaginationItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcPaginationItemElementEventMap>(type: K, listener: (this: HTMLIcPaginationItemElement, ev: IcPaginationItemCustomEvent<HTMLIcPaginationItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcPaginationItemElement: {
        prototype: HTMLIcPaginationItemElement;
        new (): HTMLIcPaginationItemElement;
    };
    interface HTMLIcPopoverMenuElementEventMap {
        "icPopoverClosed": void;
    }
    interface HTMLIcPopoverMenuElement extends Components.IcPopoverMenu, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcPopoverMenuElementEventMap>(type: K, listener: (this: HTMLIcPopoverMenuElement, ev: IcPopoverMenuCustomEvent<HTMLIcPopoverMenuElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcPopoverMenuElementEventMap>(type: K, listener: (this: HTMLIcPopoverMenuElement, ev: IcPopoverMenuCustomEvent<HTMLIcPopoverMenuElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcPopoverMenuElement: {
        prototype: HTMLIcPopoverMenuElement;
        new (): HTMLIcPopoverMenuElement;
    };
    interface HTMLIcRadioGroupElementEventMap {
        "icChange": IcChangeEventDetail2;
    }
    interface HTMLIcRadioGroupElement extends Components.IcRadioGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcRadioGroupElementEventMap>(type: K, listener: (this: HTMLIcRadioGroupElement, ev: IcRadioGroupCustomEvent<HTMLIcRadioGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcRadioGroupElementEventMap>(type: K, listener: (this: HTMLIcRadioGroupElement, ev: IcRadioGroupCustomEvent<HTMLIcRadioGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcRadioGroupElement: {
        prototype: HTMLIcRadioGroupElement;
        new (): HTMLIcRadioGroupElement;
    };
    interface HTMLIcRadioOptionElementEventMap {
        "icCheck": IcValueEventDetail;
        "radioOptionSelect": IcValueEventDetail;
        "icSelectedChange": void;
    }
    interface HTMLIcRadioOptionElement extends Components.IcRadioOption, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcRadioOptionElementEventMap>(type: K, listener: (this: HTMLIcRadioOptionElement, ev: IcRadioOptionCustomEvent<HTMLIcRadioOptionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcRadioOptionElementEventMap>(type: K, listener: (this: HTMLIcRadioOptionElement, ev: IcRadioOptionCustomEvent<HTMLIcRadioOptionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcRadioOptionElement: {
        prototype: HTMLIcRadioOptionElement;
        new (): HTMLIcRadioOptionElement;
    };
    interface HTMLIcSearchBarElementEventMap {
        "icChange": IcValueEventDetail;
        "icClear": void;
        "icInput": IcValueEventDetail;
        "icInputBlur": IcSearchBarBlurEventDetail;
        "icInputFocus": IcValueEventDetail;
        "icOptionSelect": IcOptionSelectEventDetail;
        "icMenuChange": IcMenuChangeEventDetail;
        "icClearBlur": IcBlurEventDetail;
        "icRetryLoad": IcValueEventDetail;
        "icSubmitSearch": IcValueEventDetail;
        "icSubmitSearchBlur": IcBlurEventDetail;
        "icSearchBarBlur": IcSearchBarBlurEventDetail;
        "icSearchBarFocus": void;
    }
    interface HTMLIcSearchBarElement extends Components.IcSearchBar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcSearchBarElementEventMap>(type: K, listener: (this: HTMLIcSearchBarElement, ev: IcSearchBarCustomEvent<HTMLIcSearchBarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcSearchBarElementEventMap>(type: K, listener: (this: HTMLIcSearchBarElement, ev: IcSearchBarCustomEvent<HTMLIcSearchBarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcSearchBarElement: {
        prototype: HTMLIcSearchBarElement;
        new (): HTMLIcSearchBarElement;
    };
    interface HTMLIcSectionContainerElement extends Components.IcSectionContainer, HTMLStencilElement {
    }
    var HTMLIcSectionContainerElement: {
        prototype: HTMLIcSectionContainerElement;
        new (): HTMLIcSectionContainerElement;
    };
    interface HTMLIcSelectElementEventMap {
        "icBlur": void;
        "icChange": IcValueEventDetail;
        "icClear": void;
        "icClose": void;
        "icFocus": void;
        "icInput": IcValueEventDetail;
        "icOpen": void;
        "icOptionSelect": IcOptionSelectEventDetail;
        "icRetryLoad": IcValueEventDetail;
    }
    interface HTMLIcSelectElement extends Components.IcSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcSelectElementEventMap>(type: K, listener: (this: HTMLIcSelectElement, ev: IcSelectCustomEvent<HTMLIcSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcSelectElementEventMap>(type: K, listener: (this: HTMLIcSelectElement, ev: IcSelectCustomEvent<HTMLIcSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcSelectElement: {
        prototype: HTMLIcSelectElement;
        new (): HTMLIcSelectElement;
    };
    interface HTMLIcSideNavigationElementEventMap {
        "sideNavExpanded": IcExpandedDetail;
    }
    interface HTMLIcSideNavigationElement extends Components.IcSideNavigation, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcSideNavigationElementEventMap>(type: K, listener: (this: HTMLIcSideNavigationElement, ev: IcSideNavigationCustomEvent<HTMLIcSideNavigationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcSideNavigationElementEventMap>(type: K, listener: (this: HTMLIcSideNavigationElement, ev: IcSideNavigationCustomEvent<HTMLIcSideNavigationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcSideNavigationElement: {
        prototype: HTMLIcSideNavigationElement;
        new (): HTMLIcSideNavigationElement;
    };
    interface HTMLIcSkeletonElement extends Components.IcSkeleton, HTMLStencilElement {
    }
    var HTMLIcSkeletonElement: {
        prototype: HTMLIcSkeletonElement;
        new (): HTMLIcSkeletonElement;
    };
    interface HTMLIcStatusTagElement extends Components.IcStatusTag, HTMLStencilElement {
    }
    var HTMLIcStatusTagElement: {
        prototype: HTMLIcStatusTagElement;
        new (): HTMLIcStatusTagElement;
    };
    interface HTMLIcStepElement extends Components.IcStep, HTMLStencilElement {
    }
    var HTMLIcStepElement: {
        prototype: HTMLIcStepElement;
        new (): HTMLIcStepElement;
    };
    interface HTMLIcStepperElement extends Components.IcStepper, HTMLStencilElement {
    }
    var HTMLIcStepperElement: {
        prototype: HTMLIcStepperElement;
        new (): HTMLIcStepperElement;
    };
    interface HTMLIcSwitchElementEventMap {
        "icBlur": void;
        "icChange": IcSwitchChangeEventDetail;
        "icFocus": void;
    }
    interface HTMLIcSwitchElement extends Components.IcSwitch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcSwitchElementEventMap>(type: K, listener: (this: HTMLIcSwitchElement, ev: IcSwitchCustomEvent<HTMLIcSwitchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcSwitchElementEventMap>(type: K, listener: (this: HTMLIcSwitchElement, ev: IcSwitchCustomEvent<HTMLIcSwitchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcSwitchElement: {
        prototype: HTMLIcSwitchElement;
        new (): HTMLIcSwitchElement;
    };
    interface HTMLIcTabElementEventMap {
        "tabClick": IcTabClickEventDetail;
        "tabCreated": HTMLIcTabElement;
        "tabEnabled": void;
        "tabFocus": IcTabClickEventDetail;
        "tabRemoved": void;
    }
    interface HTMLIcTabElement extends Components.IcTab, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcTabElementEventMap>(type: K, listener: (this: HTMLIcTabElement, ev: IcTabCustomEvent<HTMLIcTabElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcTabElementEventMap>(type: K, listener: (this: HTMLIcTabElement, ev: IcTabCustomEvent<HTMLIcTabElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcTabElement: {
        prototype: HTMLIcTabElement;
        new (): HTMLIcTabElement;
    };
    interface HTMLIcTabContextElementEventMap {
        "icTabSelect": IcTabSelectEventDetail;
        "tabSelect": IcTabSelectEventDetail;
    }
    interface HTMLIcTabContextElement extends Components.IcTabContext, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcTabContextElementEventMap>(type: K, listener: (this: HTMLIcTabContextElement, ev: IcTabContextCustomEvent<HTMLIcTabContextElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcTabContextElementEventMap>(type: K, listener: (this: HTMLIcTabContextElement, ev: IcTabContextCustomEvent<HTMLIcTabContextElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcTabContextElement: {
        prototype: HTMLIcTabContextElement;
        new (): HTMLIcTabContextElement;
    };
    interface HTMLIcTabGroupElement extends Components.IcTabGroup, HTMLStencilElement {
    }
    var HTMLIcTabGroupElement: {
        prototype: HTMLIcTabGroupElement;
        new (): HTMLIcTabGroupElement;
    };
    interface HTMLIcTabPanelElementEventMap {
        "tabPanelCreated": HTMLIcTabPanelElement;
        "tabPanelRemoved": void;
    }
    interface HTMLIcTabPanelElement extends Components.IcTabPanel, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcTabPanelElementEventMap>(type: K, listener: (this: HTMLIcTabPanelElement, ev: IcTabPanelCustomEvent<HTMLIcTabPanelElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcTabPanelElementEventMap>(type: K, listener: (this: HTMLIcTabPanelElement, ev: IcTabPanelCustomEvent<HTMLIcTabPanelElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcTabPanelElement: {
        prototype: HTMLIcTabPanelElement;
        new (): HTMLIcTabPanelElement;
    };
    interface HTMLIcTextFieldElementEventMap {
        "getValidationText": IcValueEventDetail;
        "icBlur": IcValueEventDetail;
        "icChange": IcValueEventDetail;
        "icFocus": IcValueEventDetail;
        "icInput": IcValueEventDetail;
        "icKeydown": { event: KeyboardEvent };
    }
    interface HTMLIcTextFieldElement extends Components.IcTextField, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcTextFieldElementEventMap>(type: K, listener: (this: HTMLIcTextFieldElement, ev: IcTextFieldCustomEvent<HTMLIcTextFieldElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcTextFieldElementEventMap>(type: K, listener: (this: HTMLIcTextFieldElement, ev: IcTextFieldCustomEvent<HTMLIcTextFieldElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcTextFieldElement: {
        prototype: HTMLIcTextFieldElement;
        new (): HTMLIcTextFieldElement;
    };
    interface HTMLIcThemeElementEventMap {
        "themeChange": IcTheme;
    }
    interface HTMLIcThemeElement extends Components.IcTheme, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcThemeElementEventMap>(type: K, listener: (this: HTMLIcThemeElement, ev: IcThemeCustomEvent<HTMLIcThemeElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcThemeElementEventMap>(type: K, listener: (this: HTMLIcThemeElement, ev: IcThemeCustomEvent<HTMLIcThemeElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcThemeElement: {
        prototype: HTMLIcThemeElement;
        new (): HTMLIcThemeElement;
    };
    interface HTMLIcToastElementEventMap {
        "icDismiss": void;
    }
    interface HTMLIcToastElement extends Components.IcToast, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcToastElementEventMap>(type: K, listener: (this: HTMLIcToastElement, ev: IcToastCustomEvent<HTMLIcToastElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcToastElementEventMap>(type: K, listener: (this: HTMLIcToastElement, ev: IcToastCustomEvent<HTMLIcToastElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcToastElement: {
        prototype: HTMLIcToastElement;
        new (): HTMLIcToastElement;
    };
    interface HTMLIcToastRegionElement extends Components.IcToastRegion, HTMLStencilElement {
    }
    var HTMLIcToastRegionElement: {
        prototype: HTMLIcToastRegionElement;
        new (): HTMLIcToastRegionElement;
    };
    interface HTMLIcToggleButtonElementEventMap {
        "icToggleChecked": {
    checked: boolean;
  };
    }
    interface HTMLIcToggleButtonElement extends Components.IcToggleButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcToggleButtonElementEventMap>(type: K, listener: (this: HTMLIcToggleButtonElement, ev: IcToggleButtonCustomEvent<HTMLIcToggleButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcToggleButtonElementEventMap>(type: K, listener: (this: HTMLIcToggleButtonElement, ev: IcToggleButtonCustomEvent<HTMLIcToggleButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcToggleButtonElement: {
        prototype: HTMLIcToggleButtonElement;
        new (): HTMLIcToggleButtonElement;
    };
    interface HTMLIcTooltipElement extends Components.IcTooltip, HTMLStencilElement {
    }
    var HTMLIcTooltipElement: {
        prototype: HTMLIcTooltipElement;
        new (): HTMLIcTooltipElement;
    };
    interface HTMLIcTopNavigationElementEventMap {
        "icNavigationMenuClosed": void;
        "icNavigationMenuOpened": void;
        "topNavResized": { size: number };
    }
    interface HTMLIcTopNavigationElement extends Components.IcTopNavigation, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIcTopNavigationElementEventMap>(type: K, listener: (this: HTMLIcTopNavigationElement, ev: IcTopNavigationCustomEvent<HTMLIcTopNavigationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIcTopNavigationElementEventMap>(type: K, listener: (this: HTMLIcTopNavigationElement, ev: IcTopNavigationCustomEvent<HTMLIcTopNavigationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIcTopNavigationElement: {
        prototype: HTMLIcTopNavigationElement;
        new (): HTMLIcTopNavigationElement;
    };
    interface HTMLIcTypographyElement extends Components.IcTypography, HTMLStencilElement {
    }
    var HTMLIcTypographyElement: {
        prototype: HTMLIcTypographyElement;
        new (): HTMLIcTypographyElement;
    };
    interface HTMLElementTagNameMap {
        "ic-accordion": HTMLIcAccordionElement;
        "ic-accordion-group": HTMLIcAccordionGroupElement;
        "ic-alert": HTMLIcAlertElement;
        "ic-back-to-top": HTMLIcBackToTopElement;
        "ic-badge": HTMLIcBadgeElement;
        "ic-breadcrumb": HTMLIcBreadcrumbElement;
        "ic-breadcrumb-group": HTMLIcBreadcrumbGroupElement;
        "ic-button": HTMLIcButtonElement;
        "ic-card": HTMLIcCardElement;
        "ic-checkbox": HTMLIcCheckboxElement;
        "ic-checkbox-group": HTMLIcCheckboxGroupElement;
        "ic-chip": HTMLIcChipElement;
        "ic-classification-banner": HTMLIcClassificationBannerElement;
        "ic-data-entity": HTMLIcDataEntityElement;
        "ic-data-row": HTMLIcDataRowElement;
        "ic-dialog": HTMLIcDialogElement;
        "ic-divider": HTMLIcDividerElement;
        "ic-empty-state": HTMLIcEmptyStateElement;
        "ic-footer": HTMLIcFooterElement;
        "ic-footer-link": HTMLIcFooterLinkElement;
        "ic-footer-link-group": HTMLIcFooterLinkGroupElement;
        "ic-hero": HTMLIcHeroElement;
        "ic-horizontal-scroll": HTMLIcHorizontalScrollElement;
        "ic-input-component-container": HTMLIcInputComponentContainerElement;
        "ic-input-container": HTMLIcInputContainerElement;
        "ic-input-label": HTMLIcInputLabelElement;
        "ic-input-validation": HTMLIcInputValidationElement;
        "ic-link": HTMLIcLinkElement;
        "ic-loading-indicator": HTMLIcLoadingIndicatorElement;
        "ic-menu": HTMLIcMenuElement;
        "ic-menu-group": HTMLIcMenuGroupElement;
        "ic-menu-item": HTMLIcMenuItemElement;
        "ic-navigation-button": HTMLIcNavigationButtonElement;
        "ic-navigation-group": HTMLIcNavigationGroupElement;
        "ic-navigation-item": HTMLIcNavigationItemElement;
        "ic-navigation-menu": HTMLIcNavigationMenuElement;
        "ic-page-header": HTMLIcPageHeaderElement;
        "ic-pagination": HTMLIcPaginationElement;
        "ic-pagination-item": HTMLIcPaginationItemElement;
        "ic-popover-menu": HTMLIcPopoverMenuElement;
        "ic-radio-group": HTMLIcRadioGroupElement;
        "ic-radio-option": HTMLIcRadioOptionElement;
        "ic-search-bar": HTMLIcSearchBarElement;
        "ic-section-container": HTMLIcSectionContainerElement;
        "ic-select": HTMLIcSelectElement;
        "ic-side-navigation": HTMLIcSideNavigationElement;
        "ic-skeleton": HTMLIcSkeletonElement;
        "ic-status-tag": HTMLIcStatusTagElement;
        "ic-step": HTMLIcStepElement;
        "ic-stepper": HTMLIcStepperElement;
        "ic-switch": HTMLIcSwitchElement;
        "ic-tab": HTMLIcTabElement;
        "ic-tab-context": HTMLIcTabContextElement;
        "ic-tab-group": HTMLIcTabGroupElement;
        "ic-tab-panel": HTMLIcTabPanelElement;
        "ic-text-field": HTMLIcTextFieldElement;
        "ic-theme": HTMLIcThemeElement;
        "ic-toast": HTMLIcToastElement;
        "ic-toast-region": HTMLIcToastRegionElement;
        "ic-toggle-button": HTMLIcToggleButtonElement;
        "ic-tooltip": HTMLIcTooltipElement;
        "ic-top-navigation": HTMLIcTopNavigationElement;
        "ic-typography": HTMLIcTypographyElement;
    }
}
declare namespace LocalJSX {
    interface IcAccordion {
        "appearance"?: IcThemeForeground;
        /**
          * If `true`, the accordion will be disabled.
         */
        "disabled"?: boolean;
        /**
          * If `true`, the accordion appears expanded.
         */
        "expanded"?: boolean;
        /**
          * The section header outlining section content.
         */
        "heading"?: string;
        /**
          * The main body message of the accordion.
         */
        "message"?: string;
        "onAccordionClicked"?: (event: IcAccordionCustomEvent<{ id: string }>) => void;
        /**
          * The size of the accordion.
         */
        "size"?: IcSizes;
    }
    interface IcAccordionGroup {
        /**
          * The accessible button label to provide more context to the 'See all/Hide all' button for screen reader users.
         */
        "accessibleButtonLabel"?: string;
        /**
          * The appearance of the accordion group, e.g dark, or light.
         */
        "appearance"?: IcThemeForeground;
        /**
          * If `true`, the accordion will load in an expanded state.
         */
        "expanded"?: boolean;
        /**
          * The header for the accordion group.
         */
        "groupTitle"?: string;
        /**
          * If `true`, only one accordion will open at a time.
         */
        "singleExpansion"?: boolean;
        /**
          * The size of the accordion.
         */
        "size"?: IcSizes;
    }
    interface IcAlert {
        /**
          * If `true`, the alert will have the 'alert' ARIA role and will be announced to screen readers.
         */
        "announced"?: boolean;
        /**
          * If `true`, the alert will have a close icon at the end to dismiss it.
         */
        "dismissible"?: boolean;
        /**
          * The optional title to display at the start of the alert.
         */
        "heading"?: string;
        /**
          * The main body message of the alert.
         */
        "message"?: string;
        /**
          * @deprecated This event should not be used anymore. Use icDismiss instead.
         */
        "onDismiss"?: (event: IcAlertCustomEvent<void>) => void;
        /**
          * Is emitted when the user dismisses the alert.
         */
        "onIcDismiss"?: (event: IcAlertCustomEvent<void>) => void;
        /**
          * If `true`, the title and message will appear above and below instead of inline.
         */
        "titleAbove"?: boolean;
        /**
          * The variant of the alert which will be rendered.
         */
        "variant"?: IcStatusVariants;
    }
    interface IcBackToTop {
        /**
          * The ID of the element to jump back to when the link is clicked.
         */
        "target": string;
    }
    interface IcBadge {
        /**
          * The accessible label of the badge component to provide context for screen reader users.
         */
        "accessibleLabel"?: string;
        /**
          * The custom badge colour. This will only style the badge component if variant="custom". Can be a hex value e.g. "#ff0000", RGB e.g. "rgb(255, 0, 0)", or RGBA e.g. "rgba(255, 0, 0, 1)".
         */
        "customColor"?: IcColor;
        /**
          * The maximum number shown on the badge appended with a +. This will only be displayed if type="text" and textLabel is not empty.
         */
        "maxNumber"?: number;
        /**
          * The positioning of the badge in reference to the parent element.
         */
        "position"?: IcBadgePositions;
        /**
          * The size of the badge to be displayed.
         */
        "size"?: IcSizes;
        /**
          * The text displayed in the badge. This will only be displayed if type="text".
         */
        "textLabel"?: string;
        /**
          * The type of badge to be displayed.
         */
        "type"?: IcBadgeTypes;
        /**
          * The variant of the badge to be displayed.
         */
        "variant"?: IcBadgeVariants;
        /**
          * If `true`, the badge will be displayed.
         */
        "visible"?: boolean;
    }
    interface IcBreadcrumb {
        "appearance"?: IcThemeForeground;
        /**
          * If `true`, aria-current will be set on the breadcrumb.
         */
        "current"?: boolean;
        /**
          * The URL that the breadcrumb link points to.
         */
        "href"?: string;
        /**
          * The title of the breadcrumb.
         */
        "pageTitle": string;
        "showBackIcon"?: boolean;
    }
    interface IcBreadcrumbGroup {
        /**
          * The appearance of the breadcrumb group.
         */
        "appearance"?: IcThemeForeground;
        /**
          * If `true`, display only a single breadcrumb for the parent page with a back icon.
         */
        "backBreadcrumbOnly"?: boolean;
        /**
          * If `true`, all breadcrumbs between the first and last breadcrumb will be collapsed.
         */
        "collapsed"?: boolean;
    }
    interface IcButton {
        /**
          * If `fileUpload` is set to `true`, this is the accepted list of file types.
         */
        "accept"?: string;
        /**
          * The appearance of the button, e.g. dark, light, or the default.
         */
        "appearance"?: IcThemeForeground;
        "ariaControlsId"?: string | boolean;
        "ariaOwnsId"?: string | boolean;
        /**
          * If `true`, the ic-tooltip which is shown for icon variant will be disabled. Title or aria-label must be set if this prop is not applied.
         */
        "disableTooltip"?: boolean;
        /**
          * If `true`, the button will be in disabled state.
         */
        "disabled"?: boolean;
        /**
          * If `true`, the user can save the linked URL instead of navigating to it.
         */
        "download"?: string | boolean;
        /**
          * If `true`, the button will show a dropdown icon.
         */
        "dropdown"?: boolean;
        /**
          * If `true`, the aria-expanded value will be set to true. This is only applied if the dropdown prop is also true.
         */
        "dropdownExpanded"?: boolean;
        /**
          * The name of the control for the file input, which is submitted with the form data.
         */
        "fileInputName"?: string;
        /**
          * If `true`, when the button is clicked the native file explorer will be launched.
         */
        "fileUpload"?: boolean;
        /**
          * The <form> element to associate the button with.
         */
        "form"?: string;
        /**
          * The URL that processes the information submitted by the button. It overrides the action attribute of the button's form owner. Does nothing if there is no form owner.
         */
        "formaction"?: string;
        /**
          * The way the submitted form data is encoded.
         */
        "formenctype"?: string;
        /**
          * The HTTP method used to submit the form.
         */
        "formmethod"?: string;
        /**
          * If `true`, the form will not be validated when submitted.
         */
        "formnovalidate"?: boolean;
        /**
          * The place to display the response from submitting the form. It overrides the target attribute of the button's form owner.
         */
        "formtarget"?: string;
        /**
          * If `true`, the button will fill the width of the container.
         */
        "fullWidth"?: boolean;
        /**
          * The URL that the link points to. This will render the button as an "a" tag.
         */
        "href"?: string;
        /**
          * The human language of the linked URL.
         */
        "hreflang"?: string;
        /**
          * If `true`, the button will be in loading state.
         */
        "loading"?: boolean;
        /**
          * If `fileUpload` is set to `true`, this boolean determines whether multiple files are accepted.
         */
        "multiple"?: boolean;
        /**
          * Emitted when button has blur
         */
        "onIcBlur"?: (event: IcButtonCustomEvent<void>) => void;
        /**
          * If `fileUpload` is set to `true`, this will be emitted when a file is selected in the native explorer.
         */
        "onIcFileSelection"?: (event: IcButtonCustomEvent<FileList>) => void;
        /**
          * Emitted when button has focus
         */
        "onIcFocus"?: (event: IcButtonCustomEvent<void>) => void;
        /**
          * How much of the referrer to send when following the link.
         */
        "referrerpolicy"?: ReferrerPolicy;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string;
        /**
          * The list of the files that have been selected by a user.
         */
        "selectedFiles"?: FileList;
        /**
          * The size of the button to be displayed.
         */
        "size"?: IcSizes;
        /**
          * The place to display the linked URL, as the name for a browsing context (a tab, window, or iframe).
         */
        "target"?: string;
        /**
          * The position of the tooltip in relation to the button.
         */
        "tooltipPlacement"?: IcButtonTooltipPlacement;
        /**
          * If `true`, the secondary variant of button will have a transparent background rather than white.
         */
        "transparentBackground"?: boolean;
        /**
          * The type of the button.
         */
        "type"?: IcButtonTypes;
        /**
          * The variant of the button to be displayed.
         */
        "variant"?: IcButtonVariants;
    }
    interface IcCard {
        /**
          * If `true`, the card will be a clickable variant, instead of static.
         */
        "clickable"?: boolean;
        /**
          * If `true`, the card will be disabled if it is clickable.
         */
        "disabled"?: boolean;
        /**
          * If `true`, the card will have an expandable area and expansion toggle button.
         */
        "expandable"?: boolean;
        /**
          * If `true`, the card will fill the width of the container.
         */
        "fullWidth"?: boolean;
        /**
          * The heading for the card. This is required, unless a slotted heading is used.
         */
        "heading"?: string;
        /**
          * The URL that the clickable card link points to. If set, the clickable card will render as an "a" tag, otherwise it will render as a button.
         */
        "href"?: string | undefined;
        /**
          * The human language of the linked URL.
         */
        "hreflang"?: string;
        /**
          * The main body message of the card.
         */
        "message"?: string;
        /**
          * How much of the referrer to send when following the link.
         */
        "referrerpolicy"?: ReferrerPolicy;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string;
        /**
          * The subheading for the card.
         */
        "subheading"?: string;
        /**
          * The place to display the linked URL, as the name for a browsing context (a tab, window, or iframe).
         */
        "target"?: string;
    }
    interface IcCheckbox {
        /**
          * The style of additionalField that will be displayed if used.
         */
        "additionalFieldDisplay"?: IcAdditionalFieldTypes;
        /**
          * If `true`, the checkbox will be set to the checked state.
         */
        "checked"?: boolean;
        /**
          * If `true`, the checkbox will be set to the disabled state.
         */
        "disabled"?: boolean;
        /**
          * The text to be displayed when dynamic.
         */
        "dynamicText"?: string;
        /**
          * The <form> element to associate the checkbox with.
         */
        "form"?: string;
        /**
          * The URL that processes the information submitted by the checkbox. It overrides the action attribute of the checkbox's form owner. Does nothing if there is no form owner.
         */
        "formaction"?: string;
        /**
          * The way the submitted form data is encoded.
         */
        "formenctype"?: string;
        /**
          * The HTTP method used to submit the form.
         */
        "formmethod"?: string;
        /**
          * If `true`, the form will not be validated when submitted.
         */
        "formnovalidate"?: boolean;
        /**
          * The place to display the response from submitting the form. It overrides the target attribute of the checkbox's form owner.
         */
        "formtarget"?: string;
        /**
          * The group label for the checkbox.
         */
        "groupLabel"?: string;
        /**
          * If `true`, the indeterminate state will be displayed when checked.
         */
        "indeterminate"?: boolean;
        /**
          * The label for the checkbox.
         */
        "label": string;
        /**
          * The name for the checkbox. If not set when used in a checkbox group, the name will be based on the group name.
         */
        "name"?: string;
        /**
          * @deprecated This event should not be used anymore. Use icCheck instead.
         */
        "onCheckboxChecked"?: (event: IcCheckboxCustomEvent<void>) => void;
        /**
          * Emitted when a checkbox has been checked.
         */
        "onIcCheck"?: (event: IcCheckboxCustomEvent<void>) => void;
        /**
          * The size of the checkbox to be displayed. This does not affect the font size of the label. If a checkbox is contained in a checkbox group, this will override the size set on checkbox group.
         */
        "size"?: IcSizes;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * The value for the checkbox.
         */
        "value": string;
    }
    interface IcCheckboxGroup {
        /**
          * If `true`, the checkbox group will be set to the disabled state.
         */
        "disabled"?: boolean;
        /**
          * The helper text that will be displayed for additional field guidance.
         */
        "helperText"?: string;
        /**
          * If `true`, the label will be hidden and the required label value will be applied as an aria-label.
         */
        "hideLabel"?: boolean;
        /**
          * The label for the checkbox group to be displayed.
         */
        "label": string;
        /**
          * The name for the checkbox group to differentiate from other groups.
         */
        "name": string;
        /**
          * Emitted when a checkbox is checked.
         */
        "onIcChange"?: (event: IcCheckboxGroupCustomEvent<IcChangeEventDetail>) => void;
        /**
          * If `true`, the checkbox group will require a value.
         */
        "required"?: boolean;
        /**
          * The size of the checkboxes to be displayed. This does not affect the font size of the label.
         */
        "size"?: IcSizes;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * The validation status - e.g. 'error' | 'warning' | 'success'.
         */
        "validationStatus"?: IcInformationStatusOrEmpty;
        /**
          * The validation text - e.g. 'error' | 'warning' | 'success'.
         */
        "validationText"?: string;
    }
    interface IcChip {
        /**
          * @deprecated This prop should not be used anymore. Use variant prop instead.
         */
        "appearance"?: IcChipAppearance;
        /**
          * If `true`, the chip will appear disabled.
         */
        "disabled"?: boolean;
        /**
          * If `true`, the chip will have a close button at the end to dismiss it.
         */
        "dismissible"?: boolean;
        /**
          * The text rendered within the chip.
         */
        "label": string;
        /**
          * @deprecated This event should not be used anymore. Use icDismiss instead.
         */
        "onDismiss"?: (event: IcChipCustomEvent<void>) => void;
        /**
          * Is emitted when the user dismisses the chip.
         */
        "onIcDismiss"?: (event: IcChipCustomEvent<void>) => void;
        /**
          * The size of the chip.
         */
        "size"?: IcSizes;
        /**
          * If `true`, the outlined variant of chip will have a transparent background rather than white.
         */
        "transparentBackground"?: boolean;
        /**
          * The emphasis of the chip.
         */
        "variant"?: IcEmphasisType;
    }
    interface IcClassificationBanner {
        /**
          * The additional information that will be displayed after the classification.
         */
        "additionalSelectors"?: string;
        /**
          * The classification level to be displayed - also determines the banner and text colour.
         */
        "classification"?: IcProtectiveMarkings;
        /**
          * The optional text that will be displayed before classification to specify relevant country/countries.
         */
        "country"?: string;
        /**
          * If `true`, the banner will appear inline with the page, instead of sticking to the bottom of the page.
         */
        "inline"?: boolean;
        /**
          * If `true`, "Up to" will be displayed before the classification and country.
         */
        "upTo"?: boolean;
    }
    interface IcDataEntity {
        /**
          * The title for the data entity.
         */
        "heading"?: string;
        /**
          * The size of the data entity component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
    }
    interface IcDataRow {
        /**
          * The label in the leftmost cell of the row.
         */
        "label"?: string;
        /**
          * The size of the data row component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * The value of the middle (right if no end-component supplied) cell of the row.
         */
        "value"?: string;
    }
    interface IcDialog {
        /**
          * @deprecated This prop should not be used anymore. Use an ic-alert/IcAlert component within an alert slot with a heading instead.
         */
        "alertHeading"?: string;
        /**
          * @deprecated This prop should not be used anymore. Use an ic-alert/IcAlert component within an alert slot with a message instead.
         */
        "alertMessage"?: string;
        /**
          * Sets the label and onclick functions for default buttons.
         */
        "buttonProps"?: { label: string; onclick: string }[];
        /**
          * If set to `false`, dialog controls will not be displayed overriding buttonProps or slotted dialog controls.
         */
        "buttons"?: boolean;
        /**
          * If set to `true`, the dialog will not close when the backdrop is clicked.
         */
        "closeOnBackdropClick"?: boolean;
        /**
          * If default buttons are displayed, sets the 'primary' or rightmost button to the destructive variant. Stops initial focus being set on the 'primary' or rightmost default or slotted button.
         */
        "destructive"?: boolean;
        /**
          * If set to `true`, the content area max height and overflow properties are removed allowing the dialog to stretch below the fold. This prop also prevents popover elements from being cut off within the content area.
         */
        "disableHeightConstraint"?: boolean;
        /**
          * If set to `true`, the content area width property is removed, allowing content to take the full width of the dialog when using the large variant.
         */
        "disableWidthConstraint"?: boolean;
        /**
          * Sets the dismiss label tooltip and aria label.
         */
        "dismissLabel"?: string;
        /**
          * Sets the heading for the dialog.
         */
        "heading": string;
        /**
          * If `true`, the close button will not be displayed.
         */
        "hideCloseButton"?: boolean;
        /**
          * Sets the optional label for the dialog which appears above the heading.
         */
        "label"?: string;
        /**
          * Cancelation event emitted when default 'Cancel' button clicked or 'cancelDialog' method is called.
         */
        "onIcDialogCancelled"?: (event: IcDialogCustomEvent<void>) => void;
        /**
          * Emitted when dialog has closed.
         */
        "onIcDialogClosed"?: (event: IcDialogCustomEvent<void>) => void;
        /**
          * Confirmation event emitted when default 'Confirm' primary button clicked or 'confirmDialog' method is called.
         */
        "onIcDialogConfirmed"?: (event: IcDialogCustomEvent<void>) => void;
        /**
          * Emitted when dialog has opened.
         */
        "onIcDialogOpened"?: (event: IcDialogCustomEvent<void>) => void;
        /**
          * If `true`, the dialog will be displayed.
         */
        "open"?: boolean;
        /**
          * Sets the maximum and minimum height and width for the dialog.
         */
        "size"?: "small" | "medium" | "large";
        /**
          * @deprecated This prop should not be used anymore. Use an ic-alert/IcAlert component within an alert slot with a variant instead.
         */
        "status"?: "neutral" | "info" | "warning" | "error" | "success";
    }
    interface IcDivider {
    }
    interface IcEmptyState {
        /**
          * The alignment of the empty state container.
         */
        "aligned"?: IcEmptyStateAlignment;
        /**
          * The body text rendered in the empty state container.
         */
        "body"?: string;
        /**
          * The number of lines of body text to display before truncating.
         */
        "bodyMaxLines"?: number;
        /**
          * The title rendered in the empty state container.
         */
        "heading"?: string;
        /**
          * The size of the image or icon used in the image slot.
         */
        "imageSize"?: IcSizes;
        /**
          * The subtitle rendered in the empty state container.
         */
        "subheading"?: string;
    }
    interface IcFooter {
        /**
          * The alignment of the section containers used within the footer.
         */
        "aligned"?: IcAlignment;
        /**
          * The screen size breakpoint at which to switch to the small layout.
         */
        "breakpoint"?: IcFooterBreakpoints;
        /**
          * The caption displayed at the bottom of the footer.
         */
        "caption"?: string;
        /**
          * If `true`, the footer will display the crown copyright at the bottom.
         */
        "copyright"?: boolean;
        /**
          * The description displayed at the top of the footer.
         */
        "description"?: string;
        /**
          * If `true`, the footer will be set up to handle link groups instead of standalone links.
         */
        "groupLinks"?: boolean;
        "onFooterResized"?: (event: IcFooterCustomEvent<void>) => void;
    }
    interface IcFooterLink {
        /**
          * If `true`, the user can save the linked URL instead of navigating to it.
         */
        "download"?: string | boolean;
        /**
          * The URL that the link points to.
         */
        "href"?: string;
        /**
          * The human language of the linked URL.
         */
        "hreflang"?: string;
        /**
          * How much of the referrer to send when following the link.
         */
        "referrerpolicy"?: ReferrerPolicy;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string;
        /**
          * The place to display the linked URL, as the name for a browsing context (a tab, window, or iframe).
         */
        "target"?: string;
    }
    interface IcFooterLinkGroup {
        /**
          * The title of the link group to be displayed.
         */
        "groupTitle": string;
    }
    interface IcHero {
        /**
          * The alignment of the hero.
         */
        "aligned"?: IcAlignment;
        /**
          * The optional background image.
         */
        "backgroundImage"?: string;
        /**
          * The alignment of the hero content.
         */
        "contentAligned"?: IcHeroContentAlignments;
        /**
          * If `true`, the background image (if set) will not scroll using a parallax effect.
         */
        "disableBackgroundParallax"?: boolean;
        /**
          * The heading of the hero.
         */
        "heading": string;
        /**
          * The optional secondary heading, replaced by slotted right content.
         */
        "secondaryHeading"?: string;
        /**
          * The optional secondary subheading, replaced by slotted right content.
         */
        "secondarySubheading"?: string;
        /**
          * The size of the hero component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * The description for the hero.
         */
        "subheading"?: string;
    }
    interface IcHorizontalScroll {
        /**
          * The appearance of the horizontal scroll, e.g. dark, light or the default.
         */
        "appearance"?: IcThemeForeground;
        "focusTrigger"?: string;
    }
    interface IcInputComponentContainer {
        /**
          * The appearance of the input component container.
         */
        "appearance"?: "dark" | "default";
        /**
          * @deprecated This prop should not be used anymore. Set prop `appearance` to "dark" instead.
         */
        "dark"?: boolean;
        /**
          * If `true`, the disabled state will be set.
         */
        "disabled"?: boolean;
        /**
          * If `true`, the input component container will fill the width of the container it is in.
         */
        "fullWidth"?: boolean;
        /**
          * If `true`, the input component container will allow for multiple lines.
         */
        "multiLine"?: boolean;
        /**
          * If `true`, the readonly state will be set.
         */
        "readonly"?: boolean;
        /**
          * The size of the input component container component.
         */
        "size"?: IcSizes;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * If `true`, the validation will display inline.
         */
        "validationInline"?: boolean;
        /**
          * The validation status of the input component container - e.g. 'error' | 'warning' | 'success'.
         */
        "validationStatus"?: IcInformationStatusOrEmpty;
    }
    interface IcInputContainer {
        /**
          * If `true`, the disabled state will be set.
         */
        "disabled"?: boolean;
        /**
          * If `true`, the readonly state will be set.
         */
        "readonly"?: boolean;
    }
    interface IcInputLabel {
        /**
          * The appearance of the input label.
         */
        "appearance"?: "dark" | "default";
        /**
          * @deprecated This prop should not be used anymore. Set prop `appearance` to "dark" instead.
         */
        "dark"?: boolean;
        /**
          * If `true`, the disabled state will be set.
         */
        "disabled"?: boolean;
        /**
          * If `true`, the input label will display with error styling.
         */
        "error"?: boolean;
        /**
          * The ID of the form element the label is bound to.
         */
        "for"?: string;
        /**
          * The helper text that will be displayed.
         */
        "helperText"?: string;
        /**
          * The text content of the label.
         */
        "label": string;
        /**
          * If `true`, the readonly state will be set.
         */
        "readonly"?: boolean;
        /**
          * If `true`, the input label will require a value.
         */
        "required"?: boolean;
    }
    interface IcInputValidation {
        /**
          * The ARIA live mode to apply to the message.
         */
        "ariaLiveMode"?: IcAriaLiveModeVariants;
        /**
          * The ID of the form element the validation is bound to.
         */
        "for"?: string;
        /**
          * If `true`, the input validation will fill the width of the container.
         */
        "fullWidth"?: boolean;
        /**
          * The validation message to display.
         */
        "message": string;
        /**
          * The status of the validation - e.g. 'error' | 'warning' | 'success'.
         */
        "status"?: IcInformationStatusOrEmpty;
    }
    interface IcLink {
        /**
          * The appearance of the link, e.g. dark, light, or default.
         */
        "appearance"?: IcThemeForeground;
        /**
          * If `true`, the user can save the linked URL instead of navigating to it.
         */
        "download"?: string | boolean;
        /**
          * The URL that the link points to.
         */
        "href"?: string;
        /**
          * The human language of the linked URL.
         */
        "hreflang"?: string;
        /**
          * How much of the referrer to send when following the link.
         */
        "referrerpolicy"?: ReferrerPolicy;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string;
        /**
          * @deprecated This prop should not be used anymore. The 'open in new tab/window' icon will display automatically if target="_blank".
         */
        "showIcon"?: boolean;
        /**
          * The place to display the linked URL, as the name for a browsing context (a tab, window, or iframe).
         */
        "target"?: string;
    }
    interface IcLoadingIndicator {
        /**
          * The appearance of the loading indicator, e.g. dark or light.
         */
        "appearance"?: IcThemeForegroundNoDefault;
        /**
          * The description that will be set as the aria-label of the loading indicator when not using a visible label.
         */
        "description"?: string;
        /**
          * If `true`, when linear, the full-width variant (i.e. without a border radius) will be displayed.
         */
        "fullWidth"?: boolean;
        "innerLabel"?: number;
        /**
          * The label to be displayed beneath the loading indicator. Display a changing label by separating multiple messages with forward slashes.
         */
        "label"?: string;
        /**
          * The time in milliseconds before the label changes.
         */
        "labelDuration"?: number;
        /**
          * The maximum value that the progress value can take. Used to calculate the proportional width of the progress bar.
         */
        "max"?: number;
        /**
          * The minimum value that the progress value can take. Used to calculate the proportional width of the progress bar.
         */
        "min"?: number;
        /**
          * The current amount of progress made. If not provided, component acts as an indeterminate loading indicator.
         */
        "progress"?: number;
        /**
          * The size of the loading indicator.
         */
        "size"?: IcLoadingSizes;
        /**
          * The type of indicator, either linear or circular.
         */
        "type"?: IcLoadingTypes;
    }
    interface IcMenu {
        /**
          * Determines whether options manually set as values (by pressing 'Enter') when they receive focus using keyboard navigation.
         */
        "activationType"?: IcActivationTypes;
        /**
          * The reference to an anchor element the menu will position itself from when rendered.
         */
        "anchorEl": HTMLElement;
        "autoFocusOnSelected"?: boolean;
        /**
          * If `true`, the menu will fill the width of the container.
         */
        "fullWidth"?: boolean;
        /**
          * The reference to the input element.
         */
        "inputEl": HTMLElement;
        /**
          * The label for the input element.
         */
        "inputLabel": string;
        /**
          * The custom name for the label field for IcMenuOption.
         */
        "labelField"?: string;
        /**
          * The ID of the menu.
         */
        "menuId": string;
        "onMenuKeyPress"?: (event: IcMenuCustomEvent<{ isNavKey: boolean; key: string }>) => void;
        "onMenuOptionId"?: (event: IcMenuCustomEvent<IcMenuOptionIdEventDetail>) => void;
        "onMenuOptionSelect"?: (event: IcMenuCustomEvent<IcOptionSelectEventDetail>) => void;
        "onMenuStateChange"?: (event: IcMenuCustomEvent<IcMenuChangeEventDetail>) => void;
        "onMenuValueChange"?: (event: IcMenuCustomEvent<IcValueEventDetail>) => void;
        "onRetryButtonClicked"?: (event: IcMenuCustomEvent<IcValueEventDetail>) => void;
        "onTimeoutBlur"?: (event: IcMenuCustomEvent<{ ev: FocusEvent }>) => void;
        "onUngroupedOptionsSet"?: (event: IcMenuCustomEvent<{ options: IcMenuOption[] }>) => void;
        /**
          * If `true`, the menu will be displayed open.
         */
        "open": boolean;
        /**
          * The possible menu selection options.
         */
        "options": IcMenuOption[];
        "parentEl"?: HTMLElement;
        /**
          * Specify the mode search bar uses to search. `navigation` allows for quick lookups of a set of values, `query` allows for more general searches.
         */
        "searchMode"?: IcSearchBarSearchModes;
        "selectOnEnter"?: boolean;
        /**
          * The size of the menu component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * The value of the currently selected option.
         */
        "value": string;
        /**
          * The custom name for the value field for IcMenuOption.
         */
        "valueField"?: string;
    }
    interface IcMenuGroup {
        /**
          * The label to display as the title of the menu group.
         */
        "label"?: string;
    }
    interface IcMenuItem {
        /**
          * The description displayed in the menu item, below the label.
         */
        "description"?: string;
        /**
          * If `true`, the menu item will be in disabled state.
         */
        "disabled"?: boolean;
        /**
          * The URL that the link points to. This will render the menu item as an "a" tag.
         */
        "href"?: string;
        /**
          * The human language of the linked URL.
         */
        "hreflang"?: string;
        /**
          * The label describing the keyboard shortcut for a menu item's action.
         */
        "keyboardShortcut"?: string;
        /**
          * The label to display in the menu item.
         */
        "label": string;
        "onChildBlur"?: (event: IcMenuItemCustomEvent<void>) => void;
        "onHandleMenuItemClick"?: (event: IcMenuItemCustomEvent<{
    label: string;
    hasSubMenu: boolean;
  }>) => void;
        "onTriggerPopoverMenuInstance"?: (event: IcMenuItemCustomEvent<void>) => void;
        /**
          * How much of the referrer to send when following the link.
         */
        "referrerpolicy"?: ReferrerPolicy;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string;
        /**
          * This references the popover menu instance that the menu item is a trigger for. If this prop is set, then the variant will always be default.
         */
        "submenuTriggerFor"?: string;
        /**
          * The place to display the linked URL, as the name for a browsing context (a tab, window, or iframe).
         */
        "target"?: string;
        /**
          * The variant of the menu item.
         */
        "variant"?: IcMenuItemVariants;
    }
    interface IcNavigationButton {
        /**
          * If `true`, the user can save the linked URL instead of navigating to it.
         */
        "download"?: string | boolean;
        /**
          * The URL that the link points to. This will render the button as an "a" tag.
         */
        "href"?: string;
        /**
          * The human language of the linked URL.
         */
        "hreflang"?: string;
        /**
          * The label info to display.
         */
        "label": string;
        /**
          * How much of the referrer to send when following the link.
         */
        "referrerpolicy"?: ReferrerPolicy;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string;
        /**
          * The place to display the linked URL, as the name for a browsing context (a tab, window, or iframe).
         */
        "target"?: string;
    }
    interface IcNavigationGroup {
        /**
          * If `true`, the group will be expandable in the side menu.
         */
        "expandable"?: boolean;
        /**
          * The label to display on the group.
         */
        "label"?: string;
    }
    interface IcNavigationItem {
        "collapsedIconLabel"?: boolean;
        "displayNavigationTooltip"?: boolean;
        /**
          * If `true`, the user can save the linked URL instead of navigating to it.
         */
        "download"?: string | boolean;
        "expandable"?: boolean;
        /**
          * The destination of the navigation item.
         */
        "href"?: string;
        /**
          * The human language of the linked URL.
         */
        "hreflang"?: string;
        /**
          * The label of the navigation item.
         */
        "label"?: string;
        "onChildBlur"?: (event: IcNavigationItemCustomEvent<void>) => void;
        "onNavItemClicked"?: (event: IcNavigationItemCustomEvent<void>) => void;
        /**
          * How much of the referrer to send when following the link.
         */
        "referrerpolicy"?: ReferrerPolicy;
        /**
          * The relationship of the linked URL as space-separated link types.
         */
        "rel"?: string;
        /**
          * If `true`, the navigation item will be set in a selected state.
         */
        "selected"?: boolean;
        /**
          * The place to display the linked URL, as the name for a browsing context (a tab, window, or iframe).
         */
        "target"?: string;
    }
    interface IcNavigationMenu {
        "onIcNavigationMenuClose"?: (event: IcNavigationMenuCustomEvent<void>) => void;
        /**
          * The status info to display.
         */
        "status"?: string;
        /**
          * The version info to display.
         */
        "version"?: string;
    }
    interface IcPageHeader {
        /**
          * The alignment of the page header.
         */
        "aligned"?: IcAlignment;
        /**
          * If `true`, a border will be displayed along the bottom of the page header.
         */
        "border"?: boolean;
        /**
          * The title to render on the page header.
         */
        "heading"?: string;
        /**
          * If `true`, the reading pattern and tab order will change in the action area for viewport widths of above 576px and when actions have not wrapped.
         */
        "reverseOrder"?: boolean;
        /**
          * The size of the page header component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * If `true`, the page header will be sticky at all breakpoints.
         */
        "sticky"?: boolean;
        /**
          * If `true`, the page header will only be sticky for viewport widths of 992px and above.
         */
        "stickyDesktopOnly"?: boolean;
        /**
          * The subtitle to render on the page header.
         */
        "subheading"?: string;
    }
    interface IcPagination {
        /**
          * The number of pages displayed adjacent to the current page when using 'complex' type pagination. Accepted values are 0, 1 & 2.
         */
        "adjacentCount"?: number;
        /**
          * The appearance of the pagination, e.g. dark, light or the default.
         */
        "appearance"?: IcThemeForeground;
        /**
          * The number of pages displayed as boundary items to the current page when using 'complex' type pagination. Accepted values are 0, 1 & 2.
         */
        "boundaryCount"?: number;
        /**
          * The current page displayed by the pagination.
         */
        "currentPage"?: number;
        /**
          * The default page to display.
         */
        "defaultPage"?: number;
        /**
          * If `true`, the pagination will not allow interaction.
         */
        "disabled"?: boolean;
        /**
          * If `true`, the current page of the simple pagination will not be displayed.
         */
        "hideCurrentPage"?: boolean;
        /**
          * If `true`, the first and last page buttons will not be displayed.
         */
        "hideFirstAndLastPageButton"?: boolean;
        /**
          * The label for the pagination item (applicable when simple pagination is being used).
         */
        "label"?: string;
        /**
          * Emitted when a page is selected.
         */
        "onIcPageChange"?: (event: IcPaginationCustomEvent<IcChangeEventDetail1>) => void;
        /**
          * The total number of pages.
         */
        "pages": number;
        /**
          * The type of pagination to be used.
         */
        "type"?: IcPaginationTypes;
    }
    interface IcPaginationItem {
        /**
          * The appearance of the pagination, e.g. dark, light or the default.
         */
        "appearance"?: IcThemeForeground;
        /**
          * If true the aria-label will be set to `Page X of Y`, where X is the current page and Y is the page count.
         */
        "ariaOverride"?: boolean;
        /**
          * If `true`, the pagination item will be disabled.
         */
        "disabled"?: boolean;
        /**
          * The label for the pagination item (applicable when simple pagination is being used).
         */
        "label"?: string;
        "onPaginationItemClick"?: (event: IcPaginationItemCustomEvent<{ page: number }>) => void;
        /**
          * The current page number.
         */
        "page"?: number | null;
        /**
          * The total number of pages.
         */
        "pages"?: number;
        /**
          * If `true`, the pagination item will be selected.
         */
        "selected"?: boolean;
        /**
          * The type of pagination item - 'page' or 'ellipsis'.
         */
        "type"?: IcPaginationItemType;
    }
    interface IcPopoverMenu {
        /**
          * The ID of the element the popover menu will anchor itself to. This is required unless the popover is a submenu.
         */
        "anchor"?: string;
        /**
          * Emitted when the popover menu is closed.
         */
        "onIcPopoverClosed"?: (event: IcPopoverMenuCustomEvent<void>) => void;
        /**
          * If `true`, the popover menu will be displayed.
         */
        "open"?: boolean;
        "parentLabel"?: string;
        "parentPopover"?: HTMLIcPopoverMenuElement;
        /**
          * The unique identifier for a popover submenu.
         */
        "submenuId"?: string;
        "submenuLevel"?: number;
    }
    interface IcRadioGroup {
        /**
          * If `true`, the disabled state will be set.
         */
        "disabled"?: boolean;
        /**
          * The helper text that will be displayed for additional field guidance.
         */
        "helperText"?: string;
        /**
          * If `true`, the label will be hidden and the required label value will be applied as an aria-label.
         */
        "hideLabel"?: boolean;
        /**
          * The label for the radio group to be displayed.
         */
        "label": string;
        /**
          * The name for the radio group to differentiate from other groups.
         */
        "name": string;
        /**
          * Emitted when a user selects a radio.
         */
        "onIcChange"?: (event: IcRadioGroupCustomEvent<IcChangeEventDetail2>) => void;
        /**
          * The orientation of the radio buttons in the radio group. If there are more than two radio buttons in a radio group or either of the radio buttons use the `additional-field` slot, then the orientation will always be vertical.
         */
        "orientation"?: IcOrientation;
        /**
          * If `true`, the radio group will require a value.
         */
        "required"?: boolean;
        /**
          * The size of the radio group component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * The validation status - e.g. 'error' | 'warning' | 'success'.
         */
        "validationStatus"?: IcInformationStatusOrEmpty;
        /**
          * The validation text - e.g. 'error' | 'warning' | 'success'.
         */
        "validationText"?: string;
    }
    interface IcRadioOption {
        /**
          * The style of additionalField that will be displayed if used.
         */
        "additionalFieldDisplay"?: IcAdditionalFieldTypes;
        /**
          * If `true`, the disabled state will be set.
         */
        "disabled"?: boolean;
        /**
          * The text to be displayed when dynamic.
         */
        "dynamicText"?: string;
        /**
          * The <form> element to associate the radio with.
         */
        "form"?: string;
        /**
          * The URL that processes the information submitted by the radio. It overrides the action attribute of the radio's form owner. Does nothing if there is no form owner.
         */
        "formaction"?: string;
        /**
          * The way the submitted form data is encoded.
         */
        "formenctype"?: string;
        /**
          * The HTTP method used to submit the form.
         */
        "formmethod"?: string;
        /**
          * If `true`, the form will not be validated when submitted.
         */
        "formnovalidate"?: boolean;
        /**
          * The place to display the response from submitting the form. It overrides the target attribute of the radio's form owner.
         */
        "formtarget"?: string;
        /**
          * The group label for the radio option.
         */
        "groupLabel"?: string;
        /**
          * The label for the radio option.
         */
        "label"?: string;
        /**
          * The name for the radio option.
         */
        "name"?: string;
        /**
          * Emitted when the radio option is selected.
         */
        "onIcCheck"?: (event: IcRadioOptionCustomEvent<IcValueEventDetail>) => void;
        /**
          * Emitted when the radio option is selected or deselected.
         */
        "onIcSelectedChange"?: (event: IcRadioOptionCustomEvent<void>) => void;
        /**
          * @deprecated This event should not be used anymore. Use icCheck instead.
         */
        "onRadioOptionSelect"?: (event: IcRadioOptionCustomEvent<IcValueEventDetail>) => void;
        /**
          * If `true`, the radio option will be displayed in a selected state.
         */
        "selected"?: boolean;
        /**
          * The value for the radio option.
         */
        "value": string;
    }
    interface IcSearchBar {
        /**
          * The automatic capitalisation of the text value as it is entered/edited by the user. Available options: "off", "none", "on", "sentences", "words", "characters".
         */
        "autocapitalize"?: string;
        /**
          * The state of autocompletion the browser can apply on the text value.
         */
        "autocomplete"?: IcAutocompleteTypes;
        /**
          * The state of autocorrection the browser can apply when the user is entering/editing the text value.
         */
        "autocorrect"?: IcAutocorrectStates;
        /**
          * If `true`, the form control will have input focus when the page loads.
         */
        "autofocus"?: boolean;
        /**
          * The number of characters until suggestions appear. The submit button will be disabled until the inputted value is equal to or greater than this number.
         */
        "charactersUntilSuggestion"?: number;
        /**
          * The amount of time, in milliseconds, to wait to trigger the `icChange` event after each keystroke.
         */
        "debounce"?: number;
        /**
          * Specify whether to disable the built in filtering. For example, if options will already be filtered from external source. If `true`, all options provided will be displayed.
         */
        "disableFilter"?: boolean;
        /**
          * If `true`, the disabled state will be set.
         */
        "disabled"?: boolean;
        /**
          * The text displayed when there are no options in the option list.
         */
        "emptyOptionListText"?: string;
        /**
          * If `true`, the search bar will be focused when component loaded.
         */
        "focusOnLoad"?: boolean;
        /**
          * Specify whether the search bar fills the full width of the container. If `true`, this overrides the --input-width CSS variable.
         */
        "fullWidth"?: boolean;
        /**
          * The helper text that will be displayed for additional field guidance.
         */
        "helperText"?: string;
        /**
          * If `true`, the label will be hidden and the required label value will be applied as an aria-label.
         */
        "hideLabel"?: boolean;
        /**
          * The hint text for the hidden assistive description element.
         */
        "hintText"?: string;
        /**
          * The label for the search bar.
         */
        "label": string;
        /**
          * The custom name for the label field to correspond with the IcMenuOption type.
         */
        "labelField"?: string;
        /**
          * Trigger loading state when fetching options asynchronously
         */
        "loading"?: boolean;
        /**
          * Change the message displayed when external loading times out.
         */
        "loadingErrorLabel"?: string;
        /**
          * Change the message displayed whilst the options are being loaded externally.
         */
        "loadingLabel"?: string;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the value has changed.
         */
        "onIcChange"?: (event: IcSearchBarCustomEvent<IcValueEventDetail>) => void;
        /**
          * Emitted when value is cleared with clear button
         */
        "onIcClear"?: (event: IcSearchBarCustomEvent<void>) => void;
        "onIcClearBlur"?: (event: IcSearchBarCustomEvent<IcBlurEventDetail>) => void;
        /**
          * Emitted when a keyboard input occurred.
         */
        "onIcInput"?: (event: IcSearchBarCustomEvent<IcValueEventDetail>) => void;
        /**
          * @deprecated This event should not be used anymore. Use icSearchBarBlur instead.
         */
        "onIcInputBlur"?: (event: IcSearchBarCustomEvent<IcSearchBarBlurEventDetail>) => void;
        /**
          * @deprecated This event should not be used anymore. Use icSearchBarFocus instead.
         */
        "onIcInputFocus"?: (event: IcSearchBarCustomEvent<IcValueEventDetail>) => void;
        /**
          * Emitted when the state of the menu changes (i.e. open or close)
         */
        "onIcMenuChange"?: (event: IcSearchBarCustomEvent<IcMenuChangeEventDetail>) => void;
        /**
          * Emitted when option is highlighted within the menu
         */
        "onIcOptionSelect"?: (event: IcSearchBarCustomEvent<IcOptionSelectEventDetail>) => void;
        /**
          * Emitted when the 'retry loading' button is clicked
         */
        "onIcRetryLoad"?: (event: IcSearchBarCustomEvent<IcValueEventDetail>) => void;
        /**
          * Emitted when blur is invoked from ic-search-bar
         */
        "onIcSearchBarBlur"?: (event: IcSearchBarCustomEvent<IcSearchBarBlurEventDetail>) => void;
        /**
          * Emitted when focus is invoked from ic-search-bar
         */
        "onIcSearchBarFocus"?: (event: IcSearchBarCustomEvent<void>) => void;
        /**
          * Emitted when the search value has been submitted
         */
        "onIcSubmitSearch"?: (event: IcSearchBarCustomEvent<IcValueEventDetail>) => void;
        "onIcSubmitSearchBlur"?: (event: IcSearchBarCustomEvent<IcBlurEventDetail>) => void;
        /**
          * The suggested search options.
         */
        "options"?: IcMenuOption[];
        /**
          * The placeholder value to display.
         */
        "placeholder"?: string;
        /**
          * If `true`, the readonly state will be set.
         */
        "readonly"?: boolean;
        /**
          * If `true`, the search bar will require a value.
         */
        "required"?: boolean;
        /**
          * Specify the mode search bar uses to search. `navigation` allows for quick lookups of a set of values, `query` allows for more general searches.
         */
        "searchMode"?: IcSearchBarSearchModes;
        /**
          * The size of the search bar component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * If `true`, the value of the search will have its spelling and grammar checked.
         */
        "spellcheck"?: boolean;
        /**
          * If using external filtering, set a timeout for when loading takes too long.
         */
        "timeout"?: number;
        /**
          * The value of the search input.
         */
        "value"?: string;
        /**
          * The custom name for the value field to correspond with the IcMenuOption type.
         */
        "valueField"?: string;
    }
    interface IcSectionContainer {
        /**
          * The alignment of the container.
         */
        "aligned"?: IcAlignment;
        /**
          * If `true`, the standard vertical padding from the container will be removed.
         */
        "fullHeight"?: boolean;
    }
    interface IcSelect {
        /**
          * @deprecated This prop should not be used anymore.
         */
        "charactersUntilSuggestions"?: number;
        /**
          * The amount of time, in milliseconds, to wait to trigger the `icChange` event after each keystroke.
         */
        "debounce"?: number;
        /**
          * If `true`, the built in filtering will be disabled for a searchable variant. For example, if options will already be filtered from external source.
         */
        "disableFilter"?: boolean;
        /**
          * If `true`, the disabled state will be set.
         */
        "disabled"?: boolean;
        /**
          * The text displayed when there are no options in the option list.
         */
        "emptyOptionListText"?: string;
        /**
          * The <form> element to associate the select with.
         */
        "form"?: string;
        /**
          * The URL that processes the information submitted by the select. It overrides the action attribute of the select's form owner. Does nothing if there is no form owner. This prop should only be used with searchable select and will only be applied if searchable is true.
         */
        "formaction"?: string;
        /**
          * The way the submitted form data is encoded. This prop should only be used with searchable select and will only be applied if searchable is true.
         */
        "formenctype"?: string;
        /**
          * The HTTP method used to submit the form. This prop should only be used with searchable select and will only be applied if searchable is true.
         */
        "formmethod"?: string;
        /**
          * If `true`, the form will not be validated when submitted. This prop should only be used with searchable select and will only be applied if searchable is true.
         */
        "formnovalidate"?: boolean;
        /**
          * The place to display the response from submitting the form. It overrides the target attribute of the select's form owner. This prop should only be used with searchable select and will only be applied if searchable is true.
         */
        "formtarget"?: string;
        /**
          * If `true`, the select element will fill the width of the container. This prop should only be used with searchable select and will only be applied if searchable is true.
         */
        "fullWidth"?: boolean;
        /**
          * The helper text that will be displayed for additional field guidance.
         */
        "helperText"?: string;
        /**
          * If `true`, the label will be hidden and the required label value will be applied as an aria-label.
         */
        "hideLabel"?: boolean;
        /**
          * If `true`, descriptions of options will be included when filtering options in a searchable select. Only applies to built in filtering.
         */
        "includeDescriptionsInSearch"?: boolean;
        /**
          * If `true`, group titles of grouped options will be included when filtering options in a searchable select. Only applies to built in filtering.
         */
        "includeGroupTitlesInSearch"?: boolean;
        /**
          * The label for the select.
         */
        "label": string;
        /**
          * If `true`, the loading state will be triggered when fetching options asynchronously.
         */
        "loading"?: boolean;
        /**
          * The message displayed when external loading times out.
         */
        "loadingErrorLabel"?: string;
        /**
          * The message displayed whilst the options are being loaded externally.
         */
        "loadingLabel"?: string;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the select loses focus.
         */
        "onIcBlur"?: (event: IcSelectCustomEvent<void>) => void;
        /**
          * Emitted when the value changes.
         */
        "onIcChange"?: (event: IcSelectCustomEvent<IcValueEventDetail>) => void;
        /**
          * Emitted when the clear button is clicked.
         */
        "onIcClear"?: (event: IcSelectCustomEvent<void>) => void;
        /**
          * Emitted when the select options menu is closed.
         */
        "onIcClose"?: (event: IcSelectCustomEvent<void>) => void;
        /**
          * Emitted when the select gains focus.
         */
        "onIcFocus"?: (event: IcSelectCustomEvent<void>) => void;
        /**
          * Emitted when a keyboard input occurred.
         */
        "onIcInput"?: (event: IcSelectCustomEvent<IcValueEventDetail>) => void;
        /**
          * Emitted when the select options menu is opened.
         */
        "onIcOpen"?: (event: IcSelectCustomEvent<void>) => void;
        /**
          * Emitted when an option is highlighted within the menu. Highlighting a menu item will also trigger an `icChange/onIcChange` due to the value being updated.
         */
        "onIcOptionSelect"?: (event: IcSelectCustomEvent<IcOptionSelectEventDetail>) => void;
        /**
          * Emitted when the 'retry loading' button is clicked for a searchable variant.
         */
        "onIcRetryLoad"?: (event: IcSelectCustomEvent<IcValueEventDetail>) => void;
        /**
          * The possible selection options.
         */
        "options"?: IcMenuOption[];
        /**
          * The placeholder value to be displayed.
         */
        "placeholder"?: string;
        /**
          * If `true`, the readonly state will be set.
         */
        "readonly"?: boolean;
        /**
          * If `true`, the select will require a value.
         */
        "required"?: boolean;
        /**
          * Whether the search string of the searchable select should match the start of or anywhere in the options. Only applies to built in filtering.
         */
        "searchMatchPosition"?: IcSearchMatchPositions;
        /**
          * If `true`, a searchable variant of the select will be displayed which can be typed in to filter options.
         */
        "searchable"?: boolean;
        /**
          * If `true`, the icOptionSelect event will be fired on enter instead of ArrowUp and ArrowDown.
         */
        "selectOnEnter"?: boolean;
        /**
          * If `true`, a button which clears the select input when clicked will be displayed. The button will always appear on the searchable select.
         */
        "showClearButton"?: boolean;
        /**
          * The size of the select component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * If using external filtering, set a timeout for when loading takes too long.
         */
        "timeout"?: number;
        /**
          * The validation status - e.g. 'error' | 'warning' | 'success'.
         */
        "validationStatus"?: IcInformationStatusOrEmpty;
        /**
          * The text to display as the validation message.
         */
        "validationText"?: string;
        /**
          * The value of the select, reflected by the value of the currently selected option. For the searchable variant, the value is also reflected by the user input.
         */
        "value"?: string;
    }
    interface IcSideNavigation {
        /**
          * The app title to be displayed. This is required, unless a slotted app title link is used.
         */
        "appTitle"?: string;
        /**
          * If `true`, the icon and label will appear when side navigation is collapsed.
         */
        "collapsedIconLabels"?: boolean;
        /**
          * If `true`, automatic parent wrapper styling will be disabled.
         */
        "disableAutoParentStyling"?: boolean;
        /**
          * If `true`, the side navigation will not display as a top bar on small devices.
         */
        "disableTopBarBehaviour"?: boolean;
        /**
          * If `true`, the side navigation will display in an expanded state.
         */
        "expanded"?: boolean;
        /**
          * The URL that the app title link points to.
         */
        "href"?: string;
        "inline"?: boolean;
        /**
          * Emitted when the side navigation is collapsed and expanded.
         */
        "onSideNavExpanded"?: (event: IcSideNavigationCustomEvent<IcExpandedDetail>) => void;
        /**
          * The short title of the app to be displayed at small screen sizes in place of the app title.
         */
        "shortAppTitle"?: string;
        /**
          * If `true`, the menu expand button will be removed (PLEASE NOTE: This takes effect on screen sizes 992px and above).
         */
        "static"?: boolean;
        /**
          * The status of the app to be displayed.
         */
        "status"?: string;
        /**
          * The version of the app to be displayed.
         */
        "version"?: string;
    }
    interface IcSkeleton {
        /**
          * The appearance of the skeleton.
         */
        "appearance"?: "light" | "default";
        /**
          * @deprecated This prop should not be used anymore. Set prop `appearance` to "light" instead.
         */
        "light"?: boolean;
        /**
          * The variant of the skeleton that will be displayed.
         */
        "variant"?: IcSkeletonVariants;
    }
    interface IcStatusTag {
        /**
          * If `true`, role='status' is added to the component and it will act as an 'aria-live' region.
         */
        "announced"?: boolean;
        /**
          * @deprecated This prop should not be used anymore. Use variant prop instead.
         */
        "appearance"?: IcStatusTagAppearance;
        /**
          * The content rendered within the status tag.
         */
        "label": string;
        /**
          * The size of the status tag component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * The colour of the status tag.
         */
        "status"?: IcStatusTagStatuses;
        /**
          * The emphasis of the status tag.
         */
        "variant"?: IcEmphasisType;
    }
    interface IcStep {
        "compactStepStyling"?: IcStepTypes;
        "current"?: boolean;
        "lastStep": boolean;
        "lastStepNum"?: number;
        "nextStepTitle"?: string;
        "progress"?: number;
        "stepNum"?: number;
        /**
          * The status of the step. Use this prop to display a status message on the step if it is required or optional.
         */
        "stepStatus"?: IcStepStatuses;
        /**
          * Additional information about the step. Use this prop to override the default step status messaging displayed when selecting a step type or step status.
         */
        "stepSubtitle"?: string;
        /**
          * The title of the step within the stepper.
         */
        "stepTitle"?: string;
        /**
          * The state of the step within the stepper.
         */
        "stepType"?: IcStepTypes;
        "variant": IcStepVariants;
    }
    interface IcStepper {
        /**
          * The alignment of the default stepper within its container.
         */
        "aligned"?: IcStepperAlignment;
        /**
          * The length of the connnector between each step in pixels. Minimum length is 100px.
         */
        "connectorWidth"?: number;
        /**
          * If `true`, the information about each step, i.e. step title, step subtitle and step status, will be hidden on all default steps. The information about each step will still be visible in the compact variant of the stepper.
         */
        "hideStepInfo"?: boolean;
        /**
          * The variant of the stepper.
         */
        "variant"?: IcStepVariants;
    }
    interface IcSwitch {
        /**
          * If `true`, the switch will display as checked.
         */
        "checked"?: boolean;
        /**
          * If `true`, the disabled state will be set.
         */
        "disabled"?: boolean;
        /**
          * The helper text that will be displayed for additional field guidance.
         */
        "helperText"?: string;
        /**
          * If `true`, the label will be hidden and the required label value will be applied as an aria-label.
         */
        "hideLabel"?: boolean;
        /**
          * The aria-label applied to the switch when no visual 'name' is provided.
         */
        "label": string;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        /**
          * Emitted when the toggle loses focus.
         */
        "onIcBlur"?: (event: IcSwitchCustomEvent<void>) => void;
        /**
          * Emitted when the value property has changed.
         */
        "onIcChange"?: (event: IcSwitchCustomEvent<IcSwitchChangeEventDetail>) => void;
        /**
          * Emitted when the toggle has focus.
         */
        "onIcFocus"?: (event: IcSwitchCustomEvent<void>) => void;
        /**
          * If `true`, the switch will render the On/Off state text.
         */
        "showState"?: boolean;
        /**
          * The size of the switch component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * The value of the toggle does not mean if it's checked or not, use the `checked` property for that.  The value of a toggle is analogous to the value of a `<input type="checkbox">`, it's only used when the toggle participates in a native `<form>`.
         */
        "value"?: string | null;
    }
    interface IcTab {
        "appearance"?: IcThemeForegroundNoDefault;
        "contextId"?: string;
        /**
          * If `true`, the disabled state will be set.
         */
        "disabled"?: boolean;
        "onTabClick"?: (event: IcTabCustomEvent<IcTabClickEventDetail>) => void;
        "onTabCreated"?: (event: IcTabCustomEvent<HTMLIcTabElement>) => void;
        "onTabEnabled"?: (event: IcTabCustomEvent<void>) => void;
        "onTabFocus"?: (event: IcTabCustomEvent<IcTabClickEventDetail>) => void;
        "onTabRemoved"?: (event: IcTabCustomEvent<void>) => void;
        "selected"?: boolean;
        "tabId"?: string;
        "tabPosition"?: number;
    }
    interface IcTabContext {
        /**
          * Determines whether tabs have to be manually activated (by pressing 'Enter' or 'Space') when they receive focus using keyboard navigation.
         */
        "activationType"?: IcActivationTypes;
        /**
          * The appearance of the tab context, e.g dark, or light.
         */
        "appearance"?: IcThemeForegroundNoDefault;
        /**
          * The unique context needed if using multiple tabs inside one another i.e. rendering another set of tabs inside a tab panel.
         */
        "contextId"?: string;
        /**
          * Emitted when a user selects a tab.
         */
        "onIcTabSelect"?: (event: IcTabContextCustomEvent<IcTabSelectEventDetail>) => void;
        /**
          * @deprecated This event should not be used anymore. Use icTabSelect instead.
         */
        "onTabSelect"?: (event: IcTabContextCustomEvent<IcTabSelectEventDetail>) => void;
        /**
          * The selected tab to be controlled by the user. Must be used alongside the icTabSelect event to manage tab selection.
         */
        "selectedTabIndex"?: number;
    }
    interface IcTabGroup {
        "appearance"?: IcThemeForegroundNoDefault;
        /**
          * @deprecated This is no longer required. The context id is passed down from `ic-tab-context`
         */
        "contextId"?: string;
        /**
          * If `true`, the tabs and tab panels will be positioned separately.
         */
        "inline"?: boolean;
        /**
          * The label to describe the purpose of the set of tabs to screen reader users.
         */
        "label": string;
    }
    interface IcTabPanel {
        "appearance"?: IcThemeForegroundNoDefault;
        /**
          * @deprecated This is no longer required. The context id is passed down from `ic-tab-context`
         */
        "contextId"?: string;
        "onTabPanelCreated"?: (event: IcTabPanelCustomEvent<HTMLIcTabPanelElement>) => void;
        "onTabPanelRemoved"?: (event: IcTabPanelCustomEvent<void>) => void;
        "panelId"?: string;
        "selectedTab"?: string;
        "tabPosition"?: number;
    }
    interface IcTextField {
        "ariaActiveDescendant"?: string;
        "ariaAutocomplete"?: IcAriaAutocompleteTypes;
        "ariaExpanded"?: string;
        "ariaOwns"?: string;
        /**
          * If `true`, the form control will have input focus when the page loads.
         */
        "autoFocus"?: boolean;
        /**
          * The automatic capitalisation of the text value as it is entered/edited by the user. Available options: "off", "none", "on", "sentences", "words", "characters".
         */
        "autocapitalize"?: string;
        /**
          * The state of autocompletion the browser can apply on the text value.
         */
        "autocomplete"?: IcAutocompleteTypes;
        /**
          * The state of autocorrection the browser can apply when the user is entering/editing the text value.
         */
        "autocorrect"?: IcAutocorrectStates;
        /**
          * The amount of time, in milliseconds, to wait to trigger the `icChange` event after each keystroke.
         */
        "debounce"?: number;
        /**
          * If `true`, the disabled state will be set.
         */
        "disabled"?: boolean;
        /**
          * Specify whether the text field fills the full width of the container. If `true`, this overrides the --input-width CSS variable.
         */
        "fullWidth"?: boolean;
        /**
          * The helper text that will be displayed for additional field guidance.
         */
        "helperText"?: string;
        "hiddenInput"?: boolean;
        /**
          * If `true`, the label will be hidden and the required label value will be applied as an aria-label.
         */
        "hideLabel"?: boolean;
        /**
          * The ID for the input.
         */
        "inputId"?: string;
        /**
          * A hint to the browser for which keyboard to display. Possible values: `"none"`, `"text"`, `"tel"`, `"url"`, `"email"`, `"numeric"`, `"decimal"`, and `"search"`.
         */
        "inputmode"?: IcTextFieldInputModes;
        /**
          * The label for the input.
         */
        "label": string;
        /**
          * The maximum number that can be accepted as a value, when `type` is `number` and `rows` is `1`. (NOTE: Ensure to include visual indication of max value in `helperText` or `label`)
         */
        "max"?: string | number;
        /**
          * The maximum number of characters that can be entered in the field.
         */
        "maxCharacters"?: number;
        /**
          * The label for maximum number of characters that can be entered in the field.
         */
        "maxLength"?: number;
        /**
          * The minimum number that can be accepted as a value, when `type` is `number` and `rows` is `1`. (NOTE: Ensure to include visual indication of min value in `helperText` or `label`)
         */
        "min"?: string | number;
        /**
          * The minimum number of characters that can be entered in the field.
         */
        "minCharacters"?: number;
        /**
          * The name of the control, which is submitted with the form data.
         */
        "name"?: string;
        "onGetValidationText"?: (event: IcTextFieldCustomEvent<IcValueEventDetail>) => void;
        /**
          * Emitted when input loses focus.
         */
        "onIcBlur"?: (event: IcTextFieldCustomEvent<IcValueEventDetail>) => void;
        /**
          * Emitted when the value has changed.
         */
        "onIcChange"?: (event: IcTextFieldCustomEvent<IcValueEventDetail>) => void;
        /**
          * Emitted when input gains focus.
         */
        "onIcFocus"?: (event: IcTextFieldCustomEvent<IcValueEventDetail>) => void;
        /**
          * Emitted when a keyboard input occurred.
         */
        "onIcInput"?: (event: IcTextFieldCustomEvent<IcValueEventDetail>) => void;
        /**
          * Emitted when a keydown event occurred.
         */
        "onIcKeydown"?: (event: IcTextFieldCustomEvent<{ event: KeyboardEvent }>) => void;
        /**
          * The placeholder value to be displayed.
         */
        "placeholder"?: string;
        /**
          * If `true`, the read only state will be set.
         */
        "readonly"?: boolean;
        /**
          * If `true`, the input will require a value.
         */
        "required"?: boolean;
        /**
          * If `true`, the multiline text area will be resizeable.
         */
        "resize"?: boolean;
        "role"?: string;
        /**
          * The number of rows to transform the text field into a text area with a specific height.
         */
        "rows"?: number;
        /**
          * The size of the text field component.
         */
        "size"?: IcSizesNoLarge;
        /**
          * @deprecated This prop should not be used anymore. Set prop `size` to "small" instead.
         */
        "small"?: boolean;
        /**
          * If `true`, the value of the text field will have its spelling and grammar checked.
         */
        "spellcheck"?: boolean;
        "truncateValue"?: boolean;
        /**
          * The type of control to display. The default type is text.
         */
        "type"?: IcTextFieldTypes;
        /**
          * If `true`, the icon in input control will be displayed - only applies when validationStatus ='success'.
         */
        "validationInline"?: boolean;
        "validationInlineInternal"?: boolean;
        /**
          * The validation state - e.g. 'error' | 'warning' | 'success'.
         */
        "validationStatus"?: IcInformationStatusOrEmpty;
        /**
          * The validation state - e.g. 'error' | 'warning' | 'success'.
         */
        "validationText"?: string;
        /**
          * The value of the text field.
         */
        "value"?: string;
    }
    interface IcTheme {
        /**
          * The theme colour. Can be a hex value e.g. "#ff0000", RGB e.g. "rgb(255, 0, 0)", or RGBA e.g. "rgba(255, 0, 0, 1)".
         */
        "color"?: string;
        "onThemeChange"?: (event: IcThemeCustomEvent<IcTheme>) => void;
    }
    interface IcToast {
        /**
          * If toast dismissMode is set to `automatic`, use this prop to define the time before the toast dismisses (in MILLISECONDS) (NOTE: Has a minimum value of `5000ms`)
         */
        "autoDismissTimeout"?: number;
        /**
          * If toast can be manually dismissed, this prop sets a custom aria-label for the ic-button component
         */
        "dismissButtonAriaLabel"?: string;
        /**
          * How the toast will be dismissed. If manual will display a dismiss button.
         */
        "dismissMode"?: IcActivationTypes;
        /**
          * The title to display at the start of the toast. (NOTE: Should be no more than `70` characters)
         */
        "heading": string;
        /**
          * The main body message of the toast. (NOTE: Should be no more than `140` characters)
         */
        "message"?: string;
        /**
          * Provides a custom alt-text to be announced to screen readers, if slotting a custom neutral icon
         */
        "neutralIconAriaLabel"?: string;
        /**
          * Is emitted when the user dismisses the toast
         */
        "onIcDismiss"?: (event: IcToastCustomEvent<void>) => void;
        /**
          * The variant of the toast being rendered
         */
        "variant"?: IcStatusVariants;
    }
    interface IcToastRegion {
        /**
          * The toast element to be displayed.
         */
        "openToast"?: HTMLIcToastElement;
    }
    interface IcToggleButton {
        /**
          * The accessible label that will be applied to the toggle button. This is required for the icon variant of toggle buttons.
         */
        "accessibleLabel"?: string;
        /**
          * The appearance of the toggle button.
         */
        "appearance"?: IcThemeForeground;
        /**
          * If `true`, the toggle button will be in disabled state.
         */
        "disabled"?: boolean;
        /**
          * If `true`, the toggle button will fill the width of the container.
         */
        "fullWidth"?: boolean;
        /**
          * The placement of the icon in relation to the toggle button label.
         */
        "iconPlacement"?: "left" | "right" | "top";
        /**
          * The label to display in the toggle button. This is required for the default variant of toggle buttons.
         */
        "label"?: string;
        /**
          * If `true`, the toggle button will be in loading state.
         */
        "loading"?: boolean;
        /**
          * Emitted when the user clicks a toggle button.
         */
        "onIcToggleChecked"?: (event: IcToggleButtonCustomEvent<{
    checked: boolean;
  }>) => void;
        /**
          * The size of the toggle button to be displayed.
         */
        "size"?: IcSizes;
        /**
          * If `true`, the toggle button will be in a checked state.
         */
        "toggleChecked"?: boolean;
        /**
          * The variant of the toggle button.
         */
        "variant"?: "default" | "icon";
    }
    interface IcTooltip {
        "disableClick"?: boolean;
        /**
          * If `true`, the tooltip will not be displayed on hover, it will require a click.
         */
        "disableHover"?: boolean;
        /**
          * The text to display on the tooltip.
         */
        "label": string;
        /**
          * The number of lines to display before truncating the text.
         */
        "maxLines"?: number;
        /**
          * The position of the tooltip in relation to the parent element.
         */
        "placement"?: IcTooltipPlacements;
        "silent"?: boolean;
        /**
          * The ID of the element the tooltip is describing - for when aria-labelledby or aria-describedby is used.
         */
        "target"?: string;
    }
    interface IcTopNavigation {
        /**
          * The app title to be displayed. This is required, unless a slotted app title link is used.
         */
        "appTitle"?: string;
        /**
          * The alignment of the top navigation content.
         */
        "contentAligned"?: IcAlignment;
        /**
          * The URL to navigate to when the app title is clicked.
         */
        "href"?: string;
        /**
          * If `true`, the flyout navigation menu on small devices will be contained by the parent element.
         */
        "inline"?: boolean;
        "onIcNavigationMenuClosed"?: (event: IcTopNavigationCustomEvent<void>) => void;
        "onIcNavigationMenuOpened"?: (event: IcTopNavigationCustomEvent<void>) => void;
        /**
          * Emitted when the top navigation is resized.
         */
        "onTopNavResized"?: (event: IcTopNavigationCustomEvent<{ size: number }>) => void;
        /**
          * The short title of the app to be displayed at small screen sizes in place of the app title.
         */
        "shortAppTitle"?: string;
        /**
          * The status info to be displayed.
         */
        "status"?: string;
        /**
          * The version info to be displayed.
         */
        "version"?: string;
    }
    interface IcTypography {
        /**
          * If `true`, appropriate top and bottom margins will be applied to the typography.
         */
        "applyVerticalMargins"?: boolean;
        /**
          * If `true`, the typography will have a bold font weight. Note: This will have no impact on variants that already use an equivalent or higher font weight (h1, h2, and subtitle-large).
         */
        "bold"?: boolean;
        /**
          * If `true`, the typography will have an italic font style.
         */
        "italic"?: boolean;
        /**
          * The number of lines to display before truncating the text, only used for the 'body' variant.
         */
        "maxLines"?: number;
        /**
          * If `true`, the typography will have a line through it.
         */
        "strikethrough"?: boolean;
        /**
          * If `true`, the typography will have a line under it.
         */
        "underline"?: boolean;
        /**
          * The ICDS typography style to use.
         */
        "variant"?: IcTypographyVariants;
    }
    interface IntrinsicElements {
        "ic-accordion": IcAccordion;
        "ic-accordion-group": IcAccordionGroup;
        "ic-alert": IcAlert;
        "ic-back-to-top": IcBackToTop;
        "ic-badge": IcBadge;
        "ic-breadcrumb": IcBreadcrumb;
        "ic-breadcrumb-group": IcBreadcrumbGroup;
        "ic-button": IcButton;
        "ic-card": IcCard;
        "ic-checkbox": IcCheckbox;
        "ic-checkbox-group": IcCheckboxGroup;
        "ic-chip": IcChip;
        "ic-classification-banner": IcClassificationBanner;
        "ic-data-entity": IcDataEntity;
        "ic-data-row": IcDataRow;
        "ic-dialog": IcDialog;
        "ic-divider": IcDivider;
        "ic-empty-state": IcEmptyState;
        "ic-footer": IcFooter;
        "ic-footer-link": IcFooterLink;
        "ic-footer-link-group": IcFooterLinkGroup;
        "ic-hero": IcHero;
        "ic-horizontal-scroll": IcHorizontalScroll;
        "ic-input-component-container": IcInputComponentContainer;
        "ic-input-container": IcInputContainer;
        "ic-input-label": IcInputLabel;
        "ic-input-validation": IcInputValidation;
        "ic-link": IcLink;
        "ic-loading-indicator": IcLoadingIndicator;
        "ic-menu": IcMenu;
        "ic-menu-group": IcMenuGroup;
        "ic-menu-item": IcMenuItem;
        "ic-navigation-button": IcNavigationButton;
        "ic-navigation-group": IcNavigationGroup;
        "ic-navigation-item": IcNavigationItem;
        "ic-navigation-menu": IcNavigationMenu;
        "ic-page-header": IcPageHeader;
        "ic-pagination": IcPagination;
        "ic-pagination-item": IcPaginationItem;
        "ic-popover-menu": IcPopoverMenu;
        "ic-radio-group": IcRadioGroup;
        "ic-radio-option": IcRadioOption;
        "ic-search-bar": IcSearchBar;
        "ic-section-container": IcSectionContainer;
        "ic-select": IcSelect;
        "ic-side-navigation": IcSideNavigation;
        "ic-skeleton": IcSkeleton;
        "ic-status-tag": IcStatusTag;
        "ic-step": IcStep;
        "ic-stepper": IcStepper;
        "ic-switch": IcSwitch;
        "ic-tab": IcTab;
        "ic-tab-context": IcTabContext;
        "ic-tab-group": IcTabGroup;
        "ic-tab-panel": IcTabPanel;
        "ic-text-field": IcTextField;
        "ic-theme": IcTheme;
        "ic-toast": IcToast;
        "ic-toast-region": IcToastRegion;
        "ic-toggle-button": IcToggleButton;
        "ic-tooltip": IcTooltip;
        "ic-top-navigation": IcTopNavigation;
        "ic-typography": IcTypography;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "ic-accordion": LocalJSX.IcAccordion & JSXBase.HTMLAttributes<HTMLIcAccordionElement>;
            "ic-accordion-group": LocalJSX.IcAccordionGroup & JSXBase.HTMLAttributes<HTMLIcAccordionGroupElement>;
            "ic-alert": LocalJSX.IcAlert & JSXBase.HTMLAttributes<HTMLIcAlertElement>;
            "ic-back-to-top": LocalJSX.IcBackToTop & JSXBase.HTMLAttributes<HTMLIcBackToTopElement>;
            "ic-badge": LocalJSX.IcBadge & JSXBase.HTMLAttributes<HTMLIcBadgeElement>;
            "ic-breadcrumb": LocalJSX.IcBreadcrumb & JSXBase.HTMLAttributes<HTMLIcBreadcrumbElement>;
            "ic-breadcrumb-group": LocalJSX.IcBreadcrumbGroup & JSXBase.HTMLAttributes<HTMLIcBreadcrumbGroupElement>;
            "ic-button": LocalJSX.IcButton & JSXBase.HTMLAttributes<HTMLIcButtonElement>;
            "ic-card": LocalJSX.IcCard & JSXBase.HTMLAttributes<HTMLIcCardElement>;
            "ic-checkbox": LocalJSX.IcCheckbox & JSXBase.HTMLAttributes<HTMLIcCheckboxElement>;
            "ic-checkbox-group": LocalJSX.IcCheckboxGroup & JSXBase.HTMLAttributes<HTMLIcCheckboxGroupElement>;
            "ic-chip": LocalJSX.IcChip & JSXBase.HTMLAttributes<HTMLIcChipElement>;
            "ic-classification-banner": LocalJSX.IcClassificationBanner & JSXBase.HTMLAttributes<HTMLIcClassificationBannerElement>;
            "ic-data-entity": LocalJSX.IcDataEntity & JSXBase.HTMLAttributes<HTMLIcDataEntityElement>;
            "ic-data-row": LocalJSX.IcDataRow & JSXBase.HTMLAttributes<HTMLIcDataRowElement>;
            "ic-dialog": LocalJSX.IcDialog & JSXBase.HTMLAttributes<HTMLIcDialogElement>;
            "ic-divider": LocalJSX.IcDivider & JSXBase.HTMLAttributes<HTMLIcDividerElement>;
            "ic-empty-state": LocalJSX.IcEmptyState & JSXBase.HTMLAttributes<HTMLIcEmptyStateElement>;
            "ic-footer": LocalJSX.IcFooter & JSXBase.HTMLAttributes<HTMLIcFooterElement>;
            "ic-footer-link": LocalJSX.IcFooterLink & JSXBase.HTMLAttributes<HTMLIcFooterLinkElement>;
            "ic-footer-link-group": LocalJSX.IcFooterLinkGroup & JSXBase.HTMLAttributes<HTMLIcFooterLinkGroupElement>;
            "ic-hero": LocalJSX.IcHero & JSXBase.HTMLAttributes<HTMLIcHeroElement>;
            "ic-horizontal-scroll": LocalJSX.IcHorizontalScroll & JSXBase.HTMLAttributes<HTMLIcHorizontalScrollElement>;
            "ic-input-component-container": LocalJSX.IcInputComponentContainer & JSXBase.HTMLAttributes<HTMLIcInputComponentContainerElement>;
            "ic-input-container": LocalJSX.IcInputContainer & JSXBase.HTMLAttributes<HTMLIcInputContainerElement>;
            "ic-input-label": LocalJSX.IcInputLabel & JSXBase.HTMLAttributes<HTMLIcInputLabelElement>;
            "ic-input-validation": LocalJSX.IcInputValidation & JSXBase.HTMLAttributes<HTMLIcInputValidationElement>;
            "ic-link": LocalJSX.IcLink & JSXBase.HTMLAttributes<HTMLIcLinkElement>;
            "ic-loading-indicator": LocalJSX.IcLoadingIndicator & JSXBase.HTMLAttributes<HTMLIcLoadingIndicatorElement>;
            "ic-menu": LocalJSX.IcMenu & JSXBase.HTMLAttributes<HTMLIcMenuElement>;
            "ic-menu-group": LocalJSX.IcMenuGroup & JSXBase.HTMLAttributes<HTMLIcMenuGroupElement>;
            "ic-menu-item": LocalJSX.IcMenuItem & JSXBase.HTMLAttributes<HTMLIcMenuItemElement>;
            "ic-navigation-button": LocalJSX.IcNavigationButton & JSXBase.HTMLAttributes<HTMLIcNavigationButtonElement>;
            "ic-navigation-group": LocalJSX.IcNavigationGroup & JSXBase.HTMLAttributes<HTMLIcNavigationGroupElement>;
            "ic-navigation-item": LocalJSX.IcNavigationItem & JSXBase.HTMLAttributes<HTMLIcNavigationItemElement>;
            "ic-navigation-menu": LocalJSX.IcNavigationMenu & JSXBase.HTMLAttributes<HTMLIcNavigationMenuElement>;
            "ic-page-header": LocalJSX.IcPageHeader & JSXBase.HTMLAttributes<HTMLIcPageHeaderElement>;
            "ic-pagination": LocalJSX.IcPagination & JSXBase.HTMLAttributes<HTMLIcPaginationElement>;
            "ic-pagination-item": LocalJSX.IcPaginationItem & JSXBase.HTMLAttributes<HTMLIcPaginationItemElement>;
            "ic-popover-menu": LocalJSX.IcPopoverMenu & JSXBase.HTMLAttributes<HTMLIcPopoverMenuElement>;
            "ic-radio-group": LocalJSX.IcRadioGroup & JSXBase.HTMLAttributes<HTMLIcRadioGroupElement>;
            "ic-radio-option": LocalJSX.IcRadioOption & JSXBase.HTMLAttributes<HTMLIcRadioOptionElement>;
            "ic-search-bar": LocalJSX.IcSearchBar & JSXBase.HTMLAttributes<HTMLIcSearchBarElement>;
            "ic-section-container": LocalJSX.IcSectionContainer & JSXBase.HTMLAttributes<HTMLIcSectionContainerElement>;
            "ic-select": LocalJSX.IcSelect & JSXBase.HTMLAttributes<HTMLIcSelectElement>;
            "ic-side-navigation": LocalJSX.IcSideNavigation & JSXBase.HTMLAttributes<HTMLIcSideNavigationElement>;
            "ic-skeleton": LocalJSX.IcSkeleton & JSXBase.HTMLAttributes<HTMLIcSkeletonElement>;
            "ic-status-tag": LocalJSX.IcStatusTag & JSXBase.HTMLAttributes<HTMLIcStatusTagElement>;
            "ic-step": LocalJSX.IcStep & JSXBase.HTMLAttributes<HTMLIcStepElement>;
            "ic-stepper": LocalJSX.IcStepper & JSXBase.HTMLAttributes<HTMLIcStepperElement>;
            "ic-switch": LocalJSX.IcSwitch & JSXBase.HTMLAttributes<HTMLIcSwitchElement>;
            "ic-tab": LocalJSX.IcTab & JSXBase.HTMLAttributes<HTMLIcTabElement>;
            "ic-tab-context": LocalJSX.IcTabContext & JSXBase.HTMLAttributes<HTMLIcTabContextElement>;
            "ic-tab-group": LocalJSX.IcTabGroup & JSXBase.HTMLAttributes<HTMLIcTabGroupElement>;
            "ic-tab-panel": LocalJSX.IcTabPanel & JSXBase.HTMLAttributes<HTMLIcTabPanelElement>;
            "ic-text-field": LocalJSX.IcTextField & JSXBase.HTMLAttributes<HTMLIcTextFieldElement>;
            "ic-theme": LocalJSX.IcTheme & JSXBase.HTMLAttributes<HTMLIcThemeElement>;
            "ic-toast": LocalJSX.IcToast & JSXBase.HTMLAttributes<HTMLIcToastElement>;
            "ic-toast-region": LocalJSX.IcToastRegion & JSXBase.HTMLAttributes<HTMLIcToastRegionElement>;
            "ic-toggle-button": LocalJSX.IcToggleButton & JSXBase.HTMLAttributes<HTMLIcToggleButtonElement>;
            "ic-tooltip": LocalJSX.IcTooltip & JSXBase.HTMLAttributes<HTMLIcTooltipElement>;
            "ic-top-navigation": LocalJSX.IcTopNavigation & JSXBase.HTMLAttributes<HTMLIcTopNavigationElement>;
            "ic-typography": LocalJSX.IcTypography & JSXBase.HTMLAttributes<HTMLIcTypographyElement>;
        }
    }
}
